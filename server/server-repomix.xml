This file is a merged representation of the entire codebase, combined into a single document by Repomix.

<file_summary>
This section contains a summary of this file.

<purpose>
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.
</purpose>

<file_format>
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files (if enabled)
5. Multiple file entries, each consisting of:
  - File path as an attribute
  - Full contents of the file
</file_format>

<usage_guidelines>
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.
</usage_guidelines>

<notes>
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded
- Files are sorted by Git change count (files with more changes are at the bottom)
</notes>

</file_summary>

<directory_structure>
config/about.txt
config/config.json
config/database.js
config/validateEnv.js
controllers/about.txt
controllers/authController.js
controllers/devController.js
controllers/errorController.js
controllers/paymentController.js
controllers/roomController.js
guidelines-server.md
middleware/about.txt
middleware/authMiddleware.js
middleware/rateLimiters.js
middleware/sanitize.js
models/Booking.js
models/index.js
models/Room.js
models/RoomImage.js
models/User.js
package.json
routes/about.txt
routes/authRoutes.js
routes/devRoutes.js
routes/paymentRoutes.js
routes/roomRoutes.js
scripts/test-api-contract.js
scripts/test-child-fee-calculation.js
scripts/test-child-policy.js
scripts/test-data-integrity.js
scripts/test-final-boss.js
scripts/test-high-priority.js
scripts/test-idor-fix.js
scripts/test-low-priority.js
scripts/test-medium-priority.js
scripts/test-price-fix.js
scripts/TRANSACTION-QUICK-REF.txt
scripts/verify_child_policy.sql
server.js
utils/AppError.js
</directory_structure>

<files>
This section contains the contents of the repository's files.

<file path="config/about.txt">
This folder acts as the central storage for settings that your application needs to function.

Database Settings: Contains scripts or configuration files (like db.js) that define how to connect to your MySQL database.

Environment Variables: Stores sensitive data like API keys, database credentials, and JWT secrets in a way that‚Äôs easy to manage across different environments (e.g., development vs. production).

Global Constants: Holds values that don't change often, such as your server's port number or external service URLs.
</file>

<file path="config/config.json">
{
  "development": {
    "username": "root",
    "password": "",
    "database": "balai_almeda_db",
    "host": "127.0.0.1",
    "dialect": "mysql"
  },
  "test": {
    "username": "root",
    "password": "",
    "database": "balai_almeda_db_test",
    "host": "127.0.0.1",
    "dialect": "mysql"
  },
  "production": {
    "username": "root",
    "password": "",
    "database": "balai_almeda_db_production",
    "host": "127.0.0.1",
    "dialect": "mysql"
  }
}
</file>

<file path="config/database.js">
const { Sequelize } = require('sequelize');
require('dotenv').config();

// Connect to the 'balai_almeda_db' database in XAMPP
const sequelize = new Sequelize(
  process.env.DB_NAME || 'balai_almeda_db', // Database name
  process.env.DB_USER || 'root',            // XAMPP default user
  process.env.DB_PASS || '',                // XAMPP default password (empty)
  {
    host: process.env.DB_HOST || 'localhost',
    dialect: 'mysql',
    logging: false, // Set to console.log to see raw SQL queries
  }
);

module.exports = sequelize;
</file>

<file path="config/validateEnv.js">
/**
 * Environment Variable Validation (Section 2.2)
 * 
 * Validates that all required environment variables are set before server starts.
 * Prevents runtime errors and security issues from missing configuration.
 */

/**
 * Validates required environment variables
 * @throws {Error} If any required variables are missing
 */
function validateRequiredEnvVars() {
  const required = [
    'JWT_SECRET',
    'DB_NAME',
    'DB_USER',
    'PAYMONGO_TEST_SECRET_KEY',
    'PAYMONGO_WEBHOOK_SECRET',
    'FRONTEND_URL'
  ];

  const missing = [];

  // Check each required variable
  required.forEach(varName => {
    if (!process.env[varName] || process.env[varName].trim() === '') {
      missing.push(varName);
    }
  });

  // If any are missing, log and exit
  if (missing.length > 0) {
    console.error('‚ùå CRITICAL ERROR: Missing required environment variables:');
    missing.forEach(varName => {
      console.error(`   - ${varName}`);
    });
    console.error('\nüí° Please set these variables in your .env file before starting the server.');
    console.error('Example .env file:');
    console.error('JWT_SECRET=your-secret-key-here');
    console.error('DB_NAME=balai_almeda_db');
    console.error('DB_USER=root');
    console.error('PAYMONGO_TEST_SECRET_KEY=sk_test_...');
    console.error('FRONTEND_URL=http://localhost:5173');
    console.error('\nüõë Server cannot start without these variables.\n');
    
    process.exit(1); // Kill the server
  }

  // Success - all variables present
  console.log('‚úÖ Environment variables validated successfully');
}

module.exports = validateRequiredEnvVars;
</file>

<file path="controllers/about.txt">
The controllers folder contains the "brain" or business logic of your application.

Request Handling: Controllers are functions that receive incoming requests from the routes, process them, and decide what response to send back to the client.

Database Interaction: This is where you write the logic to fetch, create, update, or delete data from your database (using Sequelize or raw SQL).

Data Processing: Before sending a response, a controller might calculate totals, format data, or handle errors if something goes wrong during a database operation.
</file>

<file path="controllers/authController.js">
const bcrypt = require('bcryptjs');
const jwt = require('jsonwebtoken');
const User = require('../models/User');
const Booking = require('../models/Booking');

// üîí SECURITY: JWT Secret (Section 2.1)
// No fallback - server will fail if JWT_SECRET is not set (validated on startup)
const JWT_SECRET = process.env.JWT_SECRET;

// Phone number validation regex for PH mobile numbers
const phoneRegex = /^(09|\+639|639)\d{9}$/;

// üîí SECURITY: Email validation regex (Section 2.7)
// Strict RFC 5322 compliant email validation
const emailRegex = /^[a-zA-Z0-9.!#$%&'*+/=?^_`{|}~-]+@[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(?:\.[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?)*$/;

/**
 * üîí SECURITY: Validate password strength (Section 2.6)
 * Enforces strong password policy:
 * - Minimum 8 characters
 * - At least 1 number
 * - At least 1 special character (!@#$%^&*(),.?":{}|<>)
 * 
 * @param {string} password - The password to validate
 * @returns {boolean} True if password meets all requirements
 */
const validatePasswordStrength = (password) => {
  if (!password || password.length < 8) {
    return false;
  }
  
  const hasNumber = /\d/.test(password);
  const hasSpecial = /[!@#$%^&*(),.?":{}|<>]/.test(password);
  
  return hasNumber && hasSpecial;
};

/**
 * üîí SECURITY: Validate email format (Section 2.7)
 * Uses strict regex validation to prevent invalid/malicious emails
 * 
 * @param {string} email - The email to validate
 * @returns {boolean} True if email is valid
 */
const validateEmailFormat = (email) => {
  if (!email || typeof email !== 'string') {
    return false;
  }
  
  return emailRegex.test(email.trim());
};

/**
 * Normalize phone number to standard format (09xxxxxxxxx)
 * Accepts: 09xxxxxxxxx, 639xxxxxxxxx, +639xxxxxxxxx
 * Returns: 09xxxxxxxxx
 */
const normalizePhoneNumber = (phone) => {
  if (!phone) return null;
  
  // Remove all spaces, dashes, and parentheses
  let cleanPhone = phone.replace(/[\s\-\(\)]/g, '');
  
  // Normalize to 09xxxxxxxxx format
  if (cleanPhone.startsWith('+639')) {
    cleanPhone = '0' + cleanPhone.substring(3); // +639171234567 -> 09171234567
  } else if (cleanPhone.startsWith('639')) {
    cleanPhone = '0' + cleanPhone.substring(2); // 639171234567 -> 09171234567
  }
  
  return cleanPhone;
};

/**
 * Validate phone number format
 * Returns true if valid PH mobile number
 */
const validatePhoneNumber = (phone) => {
  if (!phone) return false;
  const cleanPhone = phone.replace(/[\s\-\(\)]/g, '');
  return phoneRegex.test(cleanPhone);
};

// Register a new user
exports.signup = async (req, res) => {
  try {
    const { firstName, lastName, email, phone, password } = req.body;

    // Validate required fields
    if (!firstName || !lastName || !email || !phone || !password) {
      return res.status(400).json({ 
        success: false, 
        message: 'All fields are required' 
      });
    }

    // Trim whitespace from names
    const trimmedFirstName = firstName.trim();
    const trimmedLastName = lastName.trim();

    // üîí SECURITY: Email validation (Section 2.7)
    if (!validateEmailFormat(email)) {
      console.warn(`‚ö†Ô∏è SECURITY: Invalid email format attempt: ${email}`);
      return res.status(400).json({ 
        success: false, 
        message: 'Invalid email format' 
      });
    }

    // Validate name lengths (prevent buffer overflow)
    if (trimmedFirstName.length > 50 || trimmedLastName.length > 50) {
      return res.status(400).json({ 
        success: false, 
        message: 'Names must not exceed 50 characters' 
      });
    }

    if (trimmedFirstName.length === 0 || trimmedLastName.length === 0) {
      return res.status(400).json({ 
        success: false, 
        message: 'Names cannot be empty' 
      });
    }

    // Validate phone number format
    if (!validatePhoneNumber(phone)) {
      return res.status(400).json({ 
        success: false, 
        message: 'Invalid phone number format. Please use a valid PH mobile number (e.g., 0917... or +639...)' 
      });
    }

    // Normalize phone number to 09xxxxxxxxx format
    const normalizedPhone = normalizePhoneNumber(phone);

    // üîí SECURITY: Strong password policy (Section 2.6)
    if (!validatePasswordStrength(password)) {
      console.warn(`‚ö†Ô∏è SECURITY: Weak password attempt for email: ${email}`);
      return res.status(400).json({ 
        success: false, 
        message: 'Password must be 8+ chars with a number and special character' 
      });
    }

    // Validate password length (8-64 characters)
    if (password.length < 8) {
      return res.status(400).json({ 
        success: false, 
        message: 'Password must be at least 8 characters' 
      });
    }

    if (password.length > 64) {
      return res.status(400).json({ 
        success: false, 
        message: 'Password must not exceed 64 characters' 
      });
    }

    // Check if user already exists
    const existingUser = await User.findOne({ where: { email } });
    if (existingUser) {
      return res.status(400).json({ 
        success: false, 
        message: 'Email already registered' 
      });
    }

    // Hash password
    const hashedPassword = await bcrypt.hash(password, 10);

    // Create user - Map camelCase input to snake_case database columns
    const user = await User.create({
      first_name: trimmedFirstName,
      last_name: trimmedLastName,
      email,
      phone: normalizedPhone,
      password: hashedPassword,
      role: 'Guest'
    });

    // Generate JWT token
    const token = jwt.sign(
      { id: user.user_id, email: user.email, role: user.role },
      JWT_SECRET,
      { expiresIn: '24h' }
    );

    res.status(201).json({
      success: true,
      message: 'Account created successfully',
      token,
      user: {
        id: user.user_id,
        firstName: user.first_name,
        lastName: user.last_name,
        email: user.email,
        phone: user.phone,
        role: user.role
      }
    });
  } catch (error) {
    console.error('Signup error:', error);
    res.status(500).json({ 
      success: false, 
      message: 'Server error. Please try again later.' 
    });
  }
};

// Login user
exports.login = async (req, res) => {
  try {
    const { email, password } = req.body;

    // Validate required fields
    if (!email || !password) {
      return res.status(400).json({ 
        success: false, 
        message: 'Email and password are required' 
      });
    }

    // Find user
    const user = await User.findOne({ where: { email } });
    if (!user) {
      return res.status(401).json({ 
        success: false, 
        message: 'Invalid email or password' 
      });
    }

    // Check password
    const isPasswordValid = await bcrypt.compare(password, user.password);
    if (!isPasswordValid) {
      return res.status(401).json({ 
        success: false, 
        message: 'Invalid email or password' 
      });
    }

    // Generate JWT token
    const token = jwt.sign(
      { id: user.user_id, email: user.email, role: user.role },
      JWT_SECRET,
      { expiresIn: '24h' }
    );

    res.status(200).json({
      success: true,
      message: 'Login successful',
      token,
      user: {
        id: user.user_id,
        firstName: user.first_name,
        lastName: user.last_name,
        email: user.email,
        phone: user.phone,
        role: user.role
      }
    });
  } catch (error) {
    console.error('Login error:', error);
    res.status(500).json({ 
      success: false, 
      message: 'Server error. Please try again later.' 
    });
  }
};

// Update user profile
exports.updateProfile = async (req, res) => {
  try {
    const userId = req.userId; // From auth middleware
    const { firstName, lastName, email, phone } = req.body;

    // Validate required fields
    if (!firstName || !lastName || !email) {
      return res.status(400).json({ 
        success: false, 
        message: 'First name, last name, and email are required' 
      });
    }

    // Trim whitespace from names
    const trimmedFirstName = firstName.trim();
    const trimmedLastName = lastName.trim();

    // Validate name lengths (prevent buffer overflow)
    if (trimmedFirstName.length > 50 || trimmedLastName.length > 50) {
      return res.status(400).json({ 
        success: false, 
        message: 'Names must not exceed 50 characters' 
      });
    }

    if (trimmedFirstName.length === 0 || trimmedLastName.length === 0) {
      return res.status(400).json({ 
        success: false, 
        message: 'Names cannot be empty' 
      });
    }

    // Validate phone number if provided
    let normalizedPhone = null;
    if (phone && phone.trim()) {
      if (!validatePhoneNumber(phone)) {
        return res.status(400).json({ 
          success: false, 
          message: 'Invalid phone number format. Please use a valid PH mobile number (e.g., 0917... or +639...)' 
        });
      }
      normalizedPhone = normalizePhoneNumber(phone);
    }

    // Find user
    const user = await User.findByPk(userId);
    if (!user) {
      return res.status(404).json({ 
        success: false, 
        message: 'User not found' 
      });
    }

    // Check if email is being changed and if it's already taken
    if (email !== user.email) {
      const existingUser = await User.findOne({ where: { email } });
      if (existingUser) {
        return res.status(400).json({ 
          success: false, 
          message: 'Email already in use by another account' 
        });
      }
    }

    // Update user - Map camelCase to snake_case
    await user.update({
      first_name: trimmedFirstName,
      last_name: trimmedLastName,
      email,
      phone: normalizedPhone || user.phone
    });

    res.status(200).json({
      success: true,
      message: 'Profile updated successfully',
      user: {
        id: user.user_id,
        firstName: user.first_name,
        lastName: user.last_name,
        email: user.email,
        phone: user.phone,
        role: user.role
      }
    });
  } catch (error) {
    console.error('Update profile error:', error);
    res.status(500).json({ 
      success: false, 
      message: 'Server error. Please try again later.' 
    });
  }
};

// Change user password
exports.changePassword = async (req, res) => {
  try {
    const userId = req.userId; // From auth middleware
    const { currentPassword, newPassword } = req.body;

    // Validate required fields
    if (!currentPassword || !newPassword) {
      return res.status(400).json({ 
        success: false, 
        message: 'Current password and new password are required' 
      });
    }

    // Validate new password strength (8-64 characters)
    if (newPassword.length < 8) {
      return res.status(400).json({ 
        success: false, 
        message: 'New password must be at least 8 characters long' 
      });
    }

    if (newPassword.length > 64) {
      return res.status(400).json({ 
        success: false, 
        message: 'New password must not exceed 64 characters' 
      });
    }

    // Find user
    const user = await User.findByPk(userId);
    if (!user) {
      return res.status(404).json({ 
        success: false, 
        message: 'User not found' 
      });
    }

    // Verify current password
    const isPasswordValid = await bcrypt.compare(currentPassword, user.password);
    if (!isPasswordValid) {
      return res.status(401).json({ 
        success: false, 
        message: 'Current password is incorrect' 
      });
    }

    // Hash new password
    const hashedPassword = await bcrypt.hash(newPassword, 10);

    // Update password
    await user.update({
      password: hashedPassword
    });

    res.status(200).json({
      success: true,
      message: 'Password changed successfully'
    });
  } catch (error) {
    console.error('Change password error:', error);
    res.status(500).json({ 
      success: false, 
      message: 'Server error. Please try again later.' 
    });
  }
};

// Get user stats (registration year and total bookings)
exports.getUserStats = async (req, res) => {
  try {
    const userId = req.userId; // From auth middleware

    // Find user
    const user = await User.findByPk(userId);
    if (!user) {
      return res.status(404).json({ 
        success: false, 
        message: 'User not found' 
      });
    }

    // Get total bookings count (excluding Cancelled bookings)
    const totalBookings = await Booking.count({
      where: {
        guest_id: userId,
        status: ['Pending_Payment', 'Confirmed', 'Checked_In', 'Completed']
      }
    });

    // Extract registration year from created_at
    const registrationYear = user.created_at ? new Date(user.created_at).getFullYear() : new Date().getFullYear();

    res.status(200).json({
      success: true,
      stats: {
        memberSince: registrationYear,
        totalBookings: totalBookings
      }
    });
  } catch (error) {
    console.error('Get user stats error:', error);
    res.status(500).json({ 
      success: false, 
      message: 'Server error. Please try again later.' 
    });
  }
};
</file>

<file path="controllers/devController.js">
const Booking = require('../models/Booking');
const Room = require('../models/Room');
const { Op } = require('sequelize');

/**
 * Simulate Payment Status for Development/Testing
 * POST /api/dev/simulate-payment/:referenceCode
 * 
 * @body { status: 'paid' | 'failed' }
 * 
 * ‚ö†Ô∏è DEV ONLY - This endpoint should NEVER be available in production
 */
exports.simulatePayment = async (req, res) => {
  try {
    const { referenceCode } = req.params;
    const { status } = req.body;

    console.log(`üß™ [DEV SIMULATOR] Simulating payment for ${referenceCode} with status: ${status}`);

    // Validate status
    if (!status || !['paid', 'failed'].includes(status)) {
      return res.status(400).json({
        success: false,
        message: 'Invalid status. Must be "paid" or "failed"'
      });
    }

    // Find the booking
    const booking = await Booking.findOne({
      where: { reference_code: referenceCode },
      include: [{ model: Room, as: 'room', attributes: ['name', 'type', 'room_number'] }]
    });

    if (!booking) {
      return res.status(404).json({
        success: false,
        message: `Booking not found: ${referenceCode}`
      });
    }

    // Check if booking is in a valid state to simulate payment
    if (booking.status !== 'Pending_Payment') {
      return res.status(400).json({
        success: false,
        message: `Cannot simulate payment. Booking status is already: ${booking.status}`,
        currentStatus: booking.status
      });
    }

    // Update booking status based on simulated payment result
    let newStatus;
    if (status === 'paid') {
      newStatus = 'Confirmed';
      console.log(`‚úÖ [DEV SIMULATOR] Payment SUCCESS - Confirming booking ${referenceCode}`);
    } else if (status === 'failed') {
      newStatus = 'Cancelled';
      console.log(`‚ùå [DEV SIMULATOR] Payment FAILED - Cancelling booking ${referenceCode}`);
    }

    await booking.update({ status: newStatus });

    res.status(200).json({
      success: true,
      message: `Payment simulated successfully`,
      booking: {
        referenceCode: booking.reference_code,
        roomName: booking.room?.name,
        roomNumber: booking.room?.room_number,
        previousStatus: 'Pending_Payment',
        newStatus: newStatus,
        totalAmount: booking.total_amount,
        checkInTime: booking.check_in_time,
        checkOutTime: booking.check_out_time
      }
    });

  } catch (error) {
    console.error('‚ùå [DEV SIMULATOR] Error:', error);
    res.status(500).json({
      success: false,
      message: 'Failed to simulate payment',
      error: error.message
    });
  }
};

/**
 * Get all pending bookings (for testing)
 * GET /api/dev/pending-bookings
 * 
 * ‚ö†Ô∏è DEV ONLY - Helper endpoint to see which bookings need payment simulation
 */
exports.getPendingBookings = async (req, res) => {
  try {
    console.log(`üß™ [DEV SIMULATOR] Fetching all pending bookings...`);

    const pendingBookings = await Booking.findAll({
      where: { 
        status: 'Pending_Payment'
      },
      include: [{
        model: Room,
        as: 'room',
        attributes: ['room_id', 'name', 'type', 'room_number']
      }],
      order: [['created_at', 'DESC']],
      attributes: [
        'booking_id',
        'reference_code',
        'checkout_session_id',
        'check_in_time',
        'check_out_time',
        'duration_hours',
        'total_amount',
        'status',
        'created_at'
      ]
    });

    const formattedBookings = pendingBookings.map(booking => ({
      id: booking.booking_id,
      referenceCode: booking.reference_code,
      sessionId: booking.checkout_session_id,
      roomId: booking.room?.room_id,
      roomName: booking.room?.name,
      roomNumber: booking.room?.room_number,
      roomType: booking.room?.type,
      checkInTime: booking.check_in_time,
      checkOutTime: booking.check_out_time,
      durationHours: booking.duration_hours,
      totalAmount: parseFloat(booking.total_amount),
      status: booking.status,
      createdAt: booking.created_at,
      // Add age in minutes for easier debugging
      ageMinutes: Math.floor((new Date() - new Date(booking.created_at)) / 60000)
    }));

    console.log(`‚úÖ [DEV SIMULATOR] Found ${formattedBookings.length} pending booking(s)`);

    res.status(200).json({
      success: true,
      count: formattedBookings.length,
      bookings: formattedBookings
    });

  } catch (error) {
    console.error('‚ùå [DEV SIMULATOR] Error:', error);
    res.status(500).json({
      success: false,
      message: 'Failed to fetch pending bookings',
      error: error.message
    });
  }
};

/**
 * Get all bookings (for testing/debugging)
 * GET /api/dev/all-bookings
 * 
 * ‚ö†Ô∏è DEV ONLY - See all bookings regardless of status
 */
exports.getAllBookings = async (req, res) => {
  try {
    const { status, limit = 50 } = req.query;

    console.log(`üß™ [DEV SIMULATOR] Fetching all bookings${status ? ` with status: ${status}` : ''}...`);

    const whereClause = status ? { status } : {};

    const allBookings = await Booking.findAll({
      where: whereClause,
      include: [{
        model: Room,
        as: 'room',
        attributes: ['room_id', 'name', 'type', 'room_number']
      }],
      order: [['created_at', 'DESC']],
      limit: parseInt(limit)
    });

    const formattedBookings = allBookings.map(booking => ({
      id: booking.booking_id,
      referenceCode: booking.reference_code,
      sessionId: booking.checkout_session_id,
      guestId: booking.guest_id,
      roomId: booking.room?.room_id,
      roomName: booking.room?.name,
      roomNumber: booking.room?.room_number,
      checkInTime: booking.check_in_time,
      checkOutTime: booking.check_out_time,
      durationHours: booking.duration_hours,
      adultsCount: booking.adults_count,
      childrenCount: booking.children_count,
      totalAmount: parseFloat(booking.total_amount),
      status: booking.status,
      source: booking.source,
      createdAt: booking.created_at
    }));

    res.status(200).json({
      success: true,
      count: formattedBookings.length,
      bookings: formattedBookings
    });

  } catch (error) {
    console.error('‚ùå [DEV SIMULATOR] Error:', error);
    res.status(500).json({
      success: false,
      message: 'Failed to fetch bookings',
      error: error.message
    });
  }
};
</file>

<file path="controllers/errorController.js">
/**
 * Global Error Handling Middleware
 * Centralizes all error responses with consistent format
 */

const sendErrorDev = (err, res) => {
  res.status(err.statusCode).json({
    status: err.status,
    error: err,
    message: err.message,
    stack: err.stack
  });
};

const sendErrorProd = (err, res) => {
  // Operational, trusted error: send message to client
  if (err.isOperational) {
    res.status(err.statusCode).json({
      status: err.status,
      message: err.message
    });
  } 
  // Programming or unknown error: don't leak details
  else {
    console.error('ERROR üí•', err);
    res.status(500).json({
      status: 'error',
      message: 'Something went wrong!'
    });
  }
};

module.exports = (err, req, res, next) => {
  err.statusCode = err.statusCode || 500;
  err.status = err.status || 'error';

  if (process.env.NODE_ENV === 'production') {
    sendErrorProd(err, res);
  } else {
    sendErrorDev(err, res);
  }
};
</file>

<file path="controllers/paymentController.js">
const axios = require('axios');
const crypto = require('crypto');
const Booking = require('../models/Booking');
const Room = require('../models/Room');
const { Op } = require('sequelize');
const sequelize = require('../config/database');
const AppError = require('../utils/AppError');

// PayMongo API Configuration
const getPayMongoSecretKey = () => {
  const isLive = process.env.PAYMONGO_IS_LIVE === 'true';
  return isLive 
    ? process.env.PAYMONGO_SECRET_KEY_LIVE 
    : process.env.PAYMONGO_TEST_SECRET_KEY;
};

const PAYMONGO_SECRET_KEY = getPayMongoSecretKey();
const PAYMONGO_BASE64_KEY = Buffer.from(`${PAYMONGO_SECRET_KEY}:`).toString('base64');
const PAYMONGO_API_URL = 'https://api.paymongo.com/v1';

/**
 * Generate a reference code candidate (internal use)
 * üîí COLLISION FIX: Increased random length from 4 to 8 characters
 */
function generateReferenceCode() {
  const timestamp = Date.now().toString(36).toUpperCase();
  const random = Math.random().toString(36).substring(2, 10).toUpperCase(); // 8 chars instead of 4
  return `BKG-${timestamp}-${random}`;
}

/**
 * Generate a guaranteed-unique reference code
 * üîí COLLISION FIX: Queries database to ensure uniqueness
 * @returns {Promise<string>} A unique reference code
 */
async function generateUniqueReferenceCode() {
  let referenceCode;
  let isUnique = false;
  let attempts = 0;
  const MAX_ATTEMPTS = 10; // Safety limit to prevent infinite loops
  
  do {
    referenceCode = generateReferenceCode();
    
    // Check if this reference code already exists in database
    const existingBooking = await Booking.findOne({
      where: { reference_code: referenceCode },
      attributes: ['reference_code']
    });
    
    isUnique = !existingBooking;
    attempts++;
    
    if (!isUnique) {
      console.warn(`‚ö†Ô∏è Reference code collision detected: ${referenceCode} (attempt ${attempts})`);
    }
    
    // Safety: If we somehow hit max attempts, add extra entropy
    if (attempts >= MAX_ATTEMPTS) {
      console.error(`‚ùå Max collision retry attempts reached. Adding extra entropy.`);
      const extraRandom = Math.random().toString(36).substring(2, 6).toUpperCase();
      referenceCode = `${referenceCode}-${extraRandom}`;
      break; // Force exit with enhanced code
    }
    
  } while (!isUnique);
  
  if (attempts > 1) {
    console.log(`‚úÖ Generated unique reference code after ${attempts} attempts: ${referenceCode}`);
  }
  
  return referenceCode;
}

/**
 * Check if room is available for the requested time slot
 * Includes 30-minute cleaning gap after checkout
 */
async function checkRoomAvailability(roomId, checkInDateTime, checkOutDateTime) {
  const CLEANING_GAP_MINUTES = 30;
  
  const conflictingBookings = await Booking.findAll({
    where: {
      room_id: roomId,
      status: {
        [Op.in]: ['Pending_Payment', 'Confirmed', 'Checked_In']
      }
    }
  });

  // Check each existing booking for conflicts, accounting for 30-min cleaning time
  for (const booking of conflictingBookings) {
    const existingCheckIn = new Date(booking.check_in_time);
    const existingCheckOut = new Date(booking.check_out_time);
    
    // Add 30-minute cleaning buffer to checkout time
    const existingCheckOutWithCleaning = new Date(existingCheckOut.getTime() + CLEANING_GAP_MINUTES * 60000);
    
    // Check for overlap:
    // 1. New booking starts before existing ends (with cleaning)
    // 2. New booking ends after existing starts
    const hasOverlap = (
      checkInDateTime < existingCheckOutWithCleaning && 
      checkOutDateTime > existingCheckIn
    );
    
    if (hasOverlap) {
      return false; // Room is not available
    }
  }

  return true; // No conflicts found
}

/**
 * Helper function: Find an available room ID for a given room type and time slot
 * Returns the room_id of the first available room, or null if none available
 */
async function findAvailableRoomID(roomType, checkInDateTime, checkOutDateTime) {
  // Find all physical rooms of this type
  const roomsOfType = await Room.findAll({
    where: { 
      type: roomType,
      status: ['Available', 'Occupied'] // Exclude maintenance/dirty rooms
    }
  });

  if (roomsOfType.length === 0) {
    return null; // No rooms of this type exist
  }

  // Loop through each room and check availability
  for (const room of roomsOfType) {
    const isAvailable = await checkRoomAvailability(room.room_id, checkInDateTime, checkOutDateTime);
    if (isAvailable) {
      return room.room_id; // Return the first available room ID
    }
  }

  return null; // No rooms available
}

/**
 * Create PayMongo Checkout Session
 * POST /api/payment/create-checkout
 * 
 * Intelligently assigns an available physical room from the requested room type
 */
exports.createCheckoutSession = async (req, res, next) => {
  try {
    const {
      roomSlug,
      roomId,          // User's manually selected room ID (new parameter)
      selectedRoomId,  // Backward compatibility
      checkInDate,
      checkInTime,
      duration,
      totalAmount,
      guestInfo
    } = req.body;

    console.debug('=== CREATE CHECKOUT SESSION ===');
    console.debug(`Requested room type: ${roomSlug}`);
    
    // üîí SECURITY FIX: Prevent IDOR - Force guest_id from JWT token
    // Only Admin/Staff can book for other users
    let secureGuestId = req.userId; // Always start with authenticated user's ID
    
    if (guestInfo && guestInfo.guestId && guestInfo.guestId !== 'walk_in') {
      // If a guestId was provided, check if user has permission to use it
      const requestedGuestId = parseInt(guestInfo.guestId);
      
      if (requestedGuestId !== req.userId) {
        // User is trying to book for someone else
        const userRole = req.userRole || 'Guest';
        
        if (userRole === 'Admin' || userRole === 'FrontDesk' || userRole === 'Manager') {
          // Admin/Staff can book for others
          secureGuestId = requestedGuestId;
          console.debug(`üîë [ADMIN OVERRIDE] ${userRole} booking for guest ID: ${requestedGuestId}`);
        } else {
          // Regular user trying to manipulate guest_id - silently override
          console.log(`‚ö†Ô∏è [SECURITY] User ${req.userId} attempted to book as ${requestedGuestId}. Blocked.`);
          // Don't return error - just use their real ID to prevent enumeration
        }
      }
    }
    
    console.debug(`‚úÖ Secure Guest ID set to: ${secureGuestId}`);
    
    // Support both roomId and selectedRoomId for flexibility
    const userSelectedRoomId = roomId || selectedRoomId;
    
    if (userSelectedRoomId) {
      console.debug(`User manually selected room ID: ${userSelectedRoomId}`);
    } else {
      console.debug(`Auto-assign mode: Will find any available room of type ${roomSlug}`);
    }

    // Validation
    if (!roomSlug || !checkInDate || !checkInTime || !duration || !guestInfo) {
      return res.status(400).json({ success: false, message: 'Missing required fields' });
    }

    // üîí SECURITY: Validate duration against allowed values (prevent invalid billing)
    const validDurations = ['3', '6', '12', '24'];
    if (!validDurations.includes(duration.toString())) {
      return res.status(400).json({ 
        success: false, 
        message: 'Invalid duration. Allowed values: 3h, 6h, 12h, 24h' 
      });
    }

    // Validate 5-minute increment rule
    const [hours, minutes] = checkInTime.split(':').map(Number);
    if (minutes % 5 !== 0) {
      return res.status(400).json({ 
        success: false, 
        message: 'Check-in time must be in 5-minute increments (e.g., 14:00, 14:05, 14:10)' 
      });
    }

    // üîí DATA INTEGRITY: Date Boundaries (Section 3.3)
    // Construct check-in and check-out times first for validation
    const checkInDateTime = new Date(`${checkInDate}T${checkInTime}`);
    const checkOutDateTime = new Date(checkInDateTime);
    checkOutDateTime.setHours(checkOutDateTime.getHours() + parseInt(duration));

    // Prevent booking in the past (with 5-minute grace period for timezone/clock skew)
    const now = new Date();
    const GRACE_PERIOD_MS = 5 * 60 * 1000; // 5 minutes
    const cutoffTime = new Date(now.getTime() - GRACE_PERIOD_MS);
    
    if (checkInDateTime < cutoffTime) {
      return next(new AppError('Cannot book dates in the past', 400));
    }

    // Prevent booking too far in the future (1 year maximum)
    const oneYearFromNow = new Date(now);
    oneYearFromNow.setFullYear(oneYearFromNow.getFullYear() + 1);
    
    if (checkInDateTime > oneYearFromNow) {
      return next(new AppError('Bookings limited to 1 year in advance', 400));
    }

    // Map generic slug to room type
    const slugToType = {
      'value-room': 'Value',
      'standard-room': 'Standard',
      'deluxe-room': 'Deluxe',
      'superior-room': 'Superior',
      'suite-room': 'Suite'
    };

    let roomType = slugToType[roomSlug];
    
    // If slug not in map, try to extract type from slug
    if (!roomType) {
      roomType = roomSlug.charAt(0).toUpperCase() + roomSlug.slice(1).replace('-room', '');
    }

    // Find ALL physical rooms of this type
    const roomsOfType = await Room.findAll({
      where: { 
        type: roomType,
        status: ['Available', 'Occupied'] // Exclude maintenance/dirty rooms
      }
    });

    if (roomsOfType.length === 0) {
      return next(new AppError('Room type not found', 404));
    }

    // Date validation is done earlier in the function, dates already constructed
    let availableRoomId;
    let availableRoom;

    // PRIORITY 1: If user manually selected a specific room, verify it's available
    if (userSelectedRoomId) {
      console.debug(`[MANUAL SELECTION] Verifying room ID ${userSelectedRoomId}...`);
      
      // Check if the selected room exists and matches the type
      const selectedRoom = await Room.findOne({
        where: { room_id: parseInt(userSelectedRoomId) }
      });

      if (!selectedRoom) {
        return res.status(400).json({ 
          success: false, 
          message: 'Selected room does not exist.' 
        });
      }

      if (selectedRoom.type !== roomType) {
        return res.status(400).json({ 
          success: false, 
          message: 'Selected room does not match the requested room type.' 
        });
      }

      // Check if the selected room is available for the time slot
      const isAvailable = await checkRoomAvailability(selectedRoom.room_id, checkInDateTime, checkOutDateTime);
      
      if (!isAvailable) {
        return next(new AppError('The selected room is no longer available. Please select a different room or time slot.', 409));
      }

      availableRoomId = selectedRoom.room_id;
      availableRoom = selectedRoom;
      console.debug(`‚úÖ [MANUAL SELECTION] Room ${selectedRoom.room_number} confirmed available`);
    } else {
      // PRIORITY 2: Auto-assign the first available room of the requested type
      console.debug(`[AUTO-ASSIGN] Finding any available ${roomType} room...`);
      availableRoomId = await findAvailableRoomID(roomType, checkInDateTime, checkOutDateTime);
      
      if (!availableRoomId) {
        console.debug(`‚ùå No available rooms of type ${roomType}`);
        return next(new AppError(`All ${roomType} rooms are fully booked for the selected time. Please note: rooms require a 30-minute cleaning period between bookings.`, 409));
      }

      // Fetch the specific room details for the booking
      availableRoom = await Room.findOne({
        where: { room_id: availableRoomId }
      });

      console.debug(`‚úÖ [AUTO-ASSIGN] Assigned room ${availableRoom.room_number} (${availableRoom.name})`);
    }

    // üîí SECURITY FIX: Calculate price SERVER-SIDE (NEVER trust client input)
    // Ignore any totalAmount from request body - always derive from database
    const durationKey = `base_rate_${duration}hr`; // Column names use 'hr' suffix
    const baseRoomPrice = parseFloat(availableRoom[durationKey]);

    if (!baseRoomPrice || isNaN(baseRoomPrice)) {
      console.error(`‚ùå Invalid rate for duration ${duration}hr: ${availableRoom[durationKey]}`);
      return res.status(500).json({ 
        success: false, 
        message: 'Unable to calculate room rate. Please contact support.' 
      });
    }

    console.log(`üí∞ [PRICE CALC STEP 1] Base Room Price: ‚Ç±${baseRoomPrice}`);

    // üîí CHILD POLICY: Extract and validate child data from guestInfo
    // ROBUST DATA EXTRACTION
    let adultsCount = 1; // Default to 1 adult
    let childrenCount = 0; // Default to 0 children
    let childAges = []; // Default to empty array
    let childAddOnPrice = 0; // Initialize to zero

    // Extract adults count
    if (guestInfo && guestInfo.adults !== undefined && guestInfo.adults !== null) {
      adultsCount = parseInt(guestInfo.adults);
      if (isNaN(adultsCount)) {
        adultsCount = 1;
      }
    }

    // Extract children count
    if (guestInfo && guestInfo.children !== undefined && guestInfo.children !== null) {
      childrenCount = parseInt(guestInfo.children);
      if (isNaN(childrenCount)) {
        childrenCount = 0;
      }
    }

    console.log(`üë• [GUEST INFO] Adults: ${adultsCount}, Children: ${childrenCount}`);

    // Validate adults count
    if (adultsCount < 1 || adultsCount > 4) {
      return res.status(400).json({
        success: false,
        message: 'Invalid number of adults (1-4 allowed)'
      });
    }

    // Validate children count
    if (childrenCount < 0 || childrenCount > 2) {
      return res.status(400).json({
        success: false,
        message: 'Invalid number of children (max 2 allowed)'
      });
    }

    // üéØ ROBUST CHILD AGES PARSING
    if (childrenCount > 0) {
      console.log(`üë∂ [CHILD AGES] Raw childAges from request:`, guestInfo.childAges);
      console.log(`üë∂ [CHILD AGES] Type:`, typeof guestInfo.childAges);

      if (guestInfo.childAges !== undefined && guestInfo.childAges !== null) {
        // Handle different input formats
        if (Array.isArray(guestInfo.childAges)) {
          // Case 1: Already an array (e.g., [8, 12] or ["8", "12"])
          console.log(`üë∂ [PARSING] Input is array`);
          childAges = guestInfo.childAges
            .map(age => {
              const parsed = parseInt(age);
              console.log(`   - Parsing "${age}" ‚Üí ${parsed}`);
              return parsed;
            })
            .filter(age => !isNaN(age));
        } else if (typeof guestInfo.childAges === 'string') {
          // Case 2: String format (e.g., "8,12" or "8, 12" or "8")
          console.log(`üë∂ [PARSING] Input is string: "${guestInfo.childAges}"`);
          childAges = guestInfo.childAges
            .split(',')
            .map(age => {
              const trimmed = age.trim();
              const parsed = parseInt(trimmed);
              console.log(`   - Parsing "${trimmed}" ‚Üí ${parsed}`);
              return parsed;
            })
            .filter(age => !isNaN(age));
        } else if (typeof guestInfo.childAges === 'number') {
          // Case 3: Single number (e.g., 8)
          console.log(`üë∂ [PARSING] Input is number: ${guestInfo.childAges}`);
          childAges = [parseInt(guestInfo.childAges)];
        }

        console.log(`üë∂ [PARSED AGES] Result:`, childAges);

        // Validate ages array length matches children count
        if (childAges.length !== childrenCount) {
          console.error(`‚ùå [VALIDATION] Age count mismatch: expected ${childrenCount}, got ${childAges.length}`);
          return res.status(400).json({
            success: false,
            message: `Children count (${childrenCount}) does not match number of ages provided (${childAges.length})`
          });
        }

        // Validate each age is within 0-13 range
        for (let i = 0; i < childAges.length; i++) {
          const age = childAges[i];
          if (age < 0 || age > 13) {
            console.error(`‚ùå [VALIDATION] Invalid age: ${age} at index ${i}`);
            return res.status(400).json({
              success: false,
              message: `Child ages must be between 0 and 13 years (got ${age})`
            });
          }
        }

        // üí∞ EXPLICIT CHILD FEE CALCULATION
        console.log(`\nüí∞ [PRICE CALC STEP 2] Calculating child fees...`);
        childAddOnPrice = 0; // Reset to ensure clean calculation
        
        for (let i = 0; i < childAges.length; i++) {
          const age = childAges[i];
          console.log(`   Child ${i + 1}: Age ${age}`);
          
          if (age >= 7 && age <= 13) {
            childAddOnPrice += 150;
            console.log(`      ‚Üí CHARGEABLE (‚Ç±150) | Running total: ‚Ç±${childAddOnPrice}`);
          } else {
            console.log(`      ‚Üí FREE (age 0-6)`);
          }
        }

        console.log(`\nüë∂ [CHILD POLICY SUMMARY]`);
        console.log(`   Total Children: ${childrenCount}`);
        console.log(`   Ages: [${childAges.join(', ')}]`);
        console.log(`   Chargeable Children (7-13): ${childAges.filter(age => age >= 7 && age <= 13).length}`);
        console.log(`   Total Child Add-on Fee: ‚Ç±${childAddOnPrice}`);
      } else {
        // Children count > 0 but no ages provided
        console.error(`‚ùå [VALIDATION] Children count is ${childrenCount} but no ages provided`);
        return res.status(400).json({
          success: false,
          message: 'Child ages are required when children count is greater than 0'
        });
      }
    } else {
      console.log(`üë∂ [CHILD POLICY] No children in this booking`);
    }

    // üí∞ FINAL PRICE CALCULATION
    const serverCalculatedPrice = baseRoomPrice + childAddOnPrice;

    console.log(`\nüí∞ [PRICE CALC STEP 3] FINAL CALCULATION:`);
    console.log(`   Base Room Rate: ‚Ç±${baseRoomPrice.toFixed(2)}`);
    console.log(`   Child Add-on:   ‚Ç±${childAddOnPrice.toFixed(2)}`);
    console.log(`   ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ`);
    console.log(`   TOTAL:          ‚Ç±${serverCalculatedPrice.toFixed(2)}`);
    console.log(`\nüîê Math Check: { base: ${baseRoomPrice}, childFees: ${childAddOnPrice}, total: ${serverCalculatedPrice} }`);

    // Log if client tried to manipulate price
    if (totalAmount && parseFloat(totalAmount) !== serverCalculatedPrice) {
      console.log(`\n‚ö†Ô∏è [SECURITY] Price manipulation detected!`);
      console.log(`   Client sent:        ‚Ç±${parseFloat(totalAmount).toFixed(2)}`);
      console.log(`   Server calculated:  ‚Ç±${serverCalculatedPrice.toFixed(2)}`);
      console.log(`   ‚úÖ Enforcing server-calculated price.`);
    }

    // üîí COLLISION FIX: Generate guaranteed-unique reference code
    const referenceCode = await generateUniqueReferenceCode();
    const amountInCentavos = Math.round(serverCalculatedPrice * 100);

    const lineItems = [
      {
        name: `${availableRoom.name || availableRoom.type + ' Room'} - ${duration}h`,
        amount: amountInCentavos,
        currency: 'PHP',
        description: `Check-in: ${checkInDate} ${checkInTime}`,
        quantity: 1
      }
    ];

    // üîí SECURITY: Dynamic Frontend URL (Section 2.11)
    // Use environment variable with localhost fallback for development
    const successUrl = `${process.env.FRONTEND_URL || 'http://localhost:5173'}/booking-success?reference=${referenceCode}`;

    const checkoutPayload = {
      data: {
        attributes: {
          send_email_receipt: true,
          show_description: true,
          show_line_items: true,
          line_items: lineItems,
          payment_method_types: ['qrph'],
          description: `Booking Reference: ${referenceCode}`,
          success_url: successUrl,
          cancel_url: `${process.env.FRONTEND_URL || 'http://localhost:5173'}/booking?cancelled=true`,
          billing: {
            name: `${guestInfo.firstName} ${guestInfo.lastName}`,
            email: guestInfo.email,
            phone: guestInfo.phone
          },
          metadata: {
            reference_code: referenceCode,
            room_id: availableRoom.room_id.toString(),
            room_number: availableRoom.room_number,
            guest_id: secureGuestId.toString() // üîí IDOR FIX: Use JWT-verified ID
          }
        }
      }
    };

    // üîí TRANSACTION FIX: Use database transaction to ensure atomicity
    // If PayMongo fails, the booking will be automatically rolled back
    const result = await sequelize.transaction(async (t) => {
      // üîí RACE CONDITION FIX (Section 2.12): Pessimistic Locking
      // Lock the room row to prevent concurrent bookings
      const lockedRoom = await Room.findOne({
        where: { room_id: availableRoom.room_id },
        lock: true, // SELECT ... FOR UPDATE - locks the row until transaction completes
        transaction: t
      });

      if (!lockedRoom) {
        throw new Error('Room not found or locked by another transaction');
      }

      // Re-verify availability with the locked room to prevent race conditions
      // This ensures no other transaction can create a booking for this room until we commit
      const isStillAvailable = await checkRoomAvailability(
        lockedRoom.room_id, 
        checkInDateTime, 
        checkOutDateTime
      );

      if (!isStillAvailable) {
        throw new Error('Room is no longer available (booked by another user during your session)');
      }

      console.log(`üîí Room ${lockedRoom.room_number} locked for booking`);

      // Step 1: Create Pending Booking with the SPECIFIC physical room assigned
      // üîí SECURITY: Use secureGuestId (derived from JWT) instead of trusting client input
      const booking = await Booking.create({
        guest_id: secureGuestId, // ‚úÖ IDOR FIX: Always use JWT-verified ID
        room_id: lockedRoom.room_id, // ‚úÖ Use locked room to ensure consistency
        reference_code: referenceCode,
        checkout_session_id: null, // Will be set after PayMongo success
        check_in_time: checkInDateTime,
        check_out_time: checkOutDateTime,
        duration_hours: parseInt(duration),
        adults_count: adultsCount, // ‚úÖ Use validated count from child policy logic
        children_count: childrenCount, // ‚úÖ Use validated count from child policy logic
        child_ages: childrenCount > 0 ? childAges : null, // ‚úÖ Store ages as JSON for verification
        source: 'Web',
        status: 'Pending_Payment',
        total_amount: serverCalculatedPrice // üîí PRICE FIX: Always use server-calculated price
      }, { transaction: t });

      console.log(`üìù Pending booking created (in transaction): ${referenceCode}`);
      console.log(`üë§ Guest ID: ${secureGuestId} (verified from JWT)`);
      console.log(`üè† Assigned to: ${lockedRoom.room_number} (Room ID: ${lockedRoom.room_id})`);
      console.log(`ÔøΩ‚Äçüë©‚Äçüëß‚Äçüë¶ Guests: ${adultsCount} adult(s), ${childrenCount} child(ren)`);
      if (childrenCount > 0) {
        console.log(`üë∂ Child Ages Saved: [${childAges.join(', ')}]`);
      }
      console.log(`ÔøΩüí∞ Amount: ‚Ç±${serverCalculatedPrice} (${duration}h rate - server-verified)`);

      // Step 2: Create PayMongo checkout session
      // If this fails, the transaction will automatically rollback
      let checkoutSession;
      try {
        console.log('‚ö†Ô∏è SENDING PAYMONGO PAYLOAD:', JSON.stringify(checkoutPayload.data.attributes.payment_method_types));
        const response = await axios.post(
          `${PAYMONGO_API_URL}/checkout_sessions`,
          checkoutPayload,
          {
            headers: {
              'Content-Type': 'application/json',
              'Authorization': `Basic ${PAYMONGO_BASE64_KEY}`
            }
          }
        );

        checkoutSession = response.data.data;
        console.log(`‚úÖ PayMongo session created: ${checkoutSession.id}`);
      } catch (paymongoError) {
        console.error('‚ùå PayMongo API failed:', paymongoError.response?.data || paymongoError.message);
        // Throw error to trigger transaction rollback
        throw new Error('Failed to create PayMongo checkout session');
      }

      // Step 3: Update booking with PayMongo session ID
      await booking.update({
        checkout_session_id: checkoutSession.id
      }, { transaction: t });

      console.log(`üíæ Session ID saved to DB: ${checkoutSession.id}`);

      // Return the checkout session for use outside transaction
      return checkoutSession;
    });

    res.status(200).json({
      success: true,
      checkoutUrl: result.attributes.checkout_url,
      referenceCode: referenceCode
    });

  } catch (error) {
    console.error('Create checkout error:', error.response?.data || error.message);
    // Pass to global error handler
    next(new AppError(error.message || 'Failed to create checkout session', 500));
  }
};

/**
 * Handle PayMongo Webhook Events
 * POST /api/payment/webhook
 * 
 * üîí SECURITY (Section 2.13): Verifies webhook signature to prevent fake payment confirmations
 * PayMongo sends HMAC SHA256 signature in 'Paymongo-Signature' header
 */
exports.handleWebhook = async (req, res) => {
  try {
    // Step 1: Get the signature from headers
    const signature = req.headers['paymongo-signature'];
    
    if (!signature) {
      console.error('‚ö†Ô∏è SECURITY: Webhook rejected - Missing Paymongo-Signature header');
      return res.status(401).json({ 
        success: false,
        error: 'Missing signature' 
      });
    }

    // Step 2: Get the webhook secret from environment
    const webhookSecret = process.env.PAYMONGO_WEBHOOK_SECRET;
    
    if (!webhookSecret) {
      console.error('‚ùå CRITICAL: PAYMONGO_WEBHOOK_SECRET not set in environment');
      return res.status(500).json({ 
        success: false,
        error: 'Server configuration error' 
      });
    }

    // Step 3: Calculate expected signature using HMAC SHA256
    // req.body is a Buffer (raw bytes) because we used express.raw() middleware
    const expectedSignature = crypto
      .createHmac('sha256', webhookSecret)
      .update(req.body)
      .digest('hex');

    // Step 4: Compare signatures using timing-safe comparison (prevents timing attacks)
    let isValid = false;
    try {
      isValid = crypto.timingSafeEqual(
        Buffer.from(signature),
        Buffer.from(expectedSignature)
      );
    } catch (err) {
      // timingSafeEqual throws if lengths don't match
      console.error('‚ö†Ô∏è SECURITY: Webhook signature length mismatch');
      isValid = false;
    }

    if (!isValid) {
      console.error('‚ö†Ô∏è SECURITY: Webhook rejected - Invalid signature');
      console.error(`   Expected: ${expectedSignature.substring(0, 20)}...`);
      console.error(`   Received: ${signature.substring(0, 20)}...`);
      return res.status(401).json({ 
        success: false,
        error: 'Invalid signature' 
      });
    }

    // Step 5: Signature is valid - parse the webhook payload
    const payload = JSON.parse(req.body.toString());
    console.log('‚úÖ Webhook signature verified successfully');
    console.log('üì® Webhook event:', payload.data?.attributes?.type || 'unknown');

    // Step 6: Process the webhook event
    const eventType = payload.data?.attributes?.type;
    const eventData = payload.data?.attributes?.data;

    if (eventType === 'checkout_session.payment.paid') {
      // Payment was successful
      const checkoutSessionId = eventData?.attributes?.checkout_session_id;
      const referenceCode = eventData?.attributes?.metadata?.reference_code;

      console.log(`üí∞ Payment confirmed for checkout session: ${checkoutSessionId}`);
      console.log(`üìã Reference code: ${referenceCode}`);

      if (referenceCode) {
        // Update booking status to Confirmed
        const booking = await Booking.findOne({
          where: { reference_code: referenceCode }
        });

        if (booking) {
          await booking.update({ status: 'Confirmed' });
          console.log(`‚úÖ Booking ${referenceCode} confirmed via webhook`);
        } else {
          console.warn(`‚ö†Ô∏è Booking not found for reference: ${referenceCode}`);
        }
      }
    } else if (eventType === 'checkout_session.expired') {
      // Checkout session expired without payment
      const referenceCode = eventData?.attributes?.metadata?.reference_code;
      console.log(`‚è∞ Checkout session expired: ${referenceCode}`);
      
      if (referenceCode) {
        const booking = await Booking.findOne({
          where: { reference_code: referenceCode }
        });

        if (booking && booking.status === 'Pending_Payment') {
          await booking.update({ status: 'Cancelled' });
          console.log(`‚ùå Booking ${referenceCode} cancelled (session expired)`);
        }
      }
    } else {
      console.log(`‚ÑπÔ∏è Unhandled webhook event type: ${eventType}`);
    }

    // Always respond with 200 to acknowledge receipt
    res.status(200).json({ received: true });

  } catch (error) {
    console.error('‚ùå Webhook processing error:', error.message);
    // Still return 200 to prevent PayMongo from retrying
    res.status(200).json({ received: true, error: error.message });
  }
};

/**
 * Verify Payment Status
 * GET /api/payment/verify/:referenceCode
 */
exports.verifyPayment = async (req, res) => {
  try {
    const { referenceCode } = req.params;

    console.debug(`üîç Verifying payment for ${referenceCode}...`);

    // 1. Find Booking
    const booking = await Booking.findOne({
      where: { reference_code: referenceCode },
      include: [{ model: Room, as: 'room' }]
    });

    if (!booking) {
      console.error(`‚ùå Booking not found: ${referenceCode}`);
      return res.status(404).json({ success: false, message: 'Booking not found' });
    }

    // 2. If Pending, ask PayMongo using the saved ID
    if (booking.status === 'Pending_Payment') {
      const sessionId = booking.checkout_session_id;

      if (sessionId) {
        console.debug(`üîç Checking PayMongo for ${referenceCode} using DB Session ID: ${sessionId}...`);
        
        try {
          const response = await axios.get(
            `${PAYMONGO_API_URL}/checkout_sessions/${sessionId}`,
            { headers: { Authorization: `Basic ${PAYMONGO_BASE64_KEY}` } }
          );

          const attributes = response.data?.data?.attributes;
          const payments = attributes?.payments || [];
          const sessionStatus = attributes?.status; // e.g., 'active', 'expired'

          // LOGGING FOR DEBUGGING
          console.debug(`üßæ Session Status: ${sessionStatus}`);
          console.debug(`üßæ Payments Found: ${payments.length}`);
          if (payments.length > 0) {
             console.debug('Payment Details:', JSON.stringify(payments[0].attributes, null, 2));
          }

          // 3. CHECK FOR PAID STATUS
          // We look for ANY payment in the list that is 'paid'
          const paidPayment = payments.find(p => p.attributes.status === 'paid');

          if (paidPayment) {
            console.debug(`üí≥ Payment Confirmed! ID: ${paidPayment.id}`);
            await booking.update({ status: 'Confirmed' });
            booking.status = 'Confirmed';
            console.debug(`‚úÖ Database updated to Confirmed.`);
          } else {
            // 4. CHECK FOR FAILED STATUS
            const failedPayment = payments.find(p => p.attributes.status === 'failed');
            const isSessionExpired = sessionStatus === 'expired';

            if (failedPayment || isSessionExpired) {
              if (failedPayment) {
                console.debug(`‚ùå Payment Failed! ID: ${failedPayment.id}`);
              }
              if (isSessionExpired) {
                console.debug(`‚è∞ Session Expired!`);
              }
              
              await booking.update({ status: 'Cancelled' });
              booking.status = 'Cancelled';
              console.debug(`üö´ Database updated to Cancelled.`);
            } else {
              console.debug(`‚è≥ No successful payment found yet. Status remains Pending.`);
            }
          }

        } catch (pmError) {
          console.error('‚ùå PayMongo Lookup Error:', pmError.message);
          if (pmError.response) {
            console.error('API Error Data:', JSON.stringify(pmError.response.data, null, 2));
          }
        }
      } else {
        console.debug(`‚ö†Ô∏è No checkout_session_id found in database for ${referenceCode}.`);
      }
    } else {
      console.debug(`‚úì Booking ${referenceCode} is already ${booking.status}`);
    }

    // 4. Return Response
    const statusMap = {
      'Pending_Payment': 'pending',
      'Confirmed': 'confirmed',
      'Checked_In': 'confirmed',
      'Completed': 'confirmed',
      'Cancelled': 'cancelled'
    };

    res.status(200).json({
      success: true,
      status: statusMap[booking.status],
      booking: {
        referenceCode: booking.reference_code,
        roomName: booking.room?.name,
        checkInTime: booking.check_in_time,
        checkOutTime: booking.check_out_time,
        durationHours: booking.duration_hours,
        totalAmount: booking.total_amount,
        status: booking.status
      }
    });

  } catch (error) {
    console.error('Verify Error:', error);
    res.status(500).json({ success: false, message: 'Verification failed' });
  }
};

/**
 * Get Booking by Reference
 */
exports.getBookingByReference = async (req, res) => {
  try {
    const { referenceCode } = req.params;
    const booking = await Booking.findOne({
      where: { reference_code: referenceCode },
      include: [{ model: Room, as: 'room' }]
    });

    if (!booking) return res.status(404).json({ success: false, message: 'Booking not found' });

    res.status(200).json({
      success: true,
      booking: {
        referenceCode: booking.reference_code,
        roomId: booking.room_id,
        roomName: booking.room?.name,
        checkInTime: booking.check_in_time,
        checkOutTime: booking.check_out_time,
        totalAmount: booking.total_amount,
        status: booking.status
      }
    });
  } catch (error) {
    console.error('Get booking error:', error);
    res.status(500).json({ success: false, message: 'Failed to retrieve booking' });
  }
};

/**
 * Get all bookings for authenticated user
 * @route GET /api/payment/my-bookings
 */
const getUserBookings = async (req, res) => {
  try {
    // FIX 1: Use req.userId (from authMiddleware)
    const userId = req.userId;

    const bookings = await Booking.findAll({
      // FIX 2: Use 'guest_id' instead of 'user_id'
      where: { guest_id: userId },
      include: [{
        model: Room,
        as: 'room',
        // FIX 3: Use correct column names from your Room model
        attributes: ['room_id', 'name', 'type', 'slug', 'image', 'base_rate_3hr']
      }],
      order: [['check_in_time', 'DESC']],
      attributes: [
        'booking_id',
        'reference_code',
        'check_in_time',
        'check_out_time',
        'total_amount',
        'status',
        'source',
        'created_at'
      ]
    });

    const formattedBookings = bookings.map(booking => ({
      id: booking.booking_id,
      referenceCode: booking.reference_code,
      roomId: booking.room?.room_id,
      roomName: booking.room?.name,
      roomType: booking.room?.type,
      roomImage: booking.room?.image,
      checkInTime: booking.check_in_time,
      checkOutTime: booking.check_out_time,
      totalAmount: parseFloat(booking.total_amount),
      status: booking.status,
      paymentStatus: (booking.status === 'Confirmed' || booking.status === 'Checked_In') ? 'paid' : 'pending',
      createdAt: booking.created_at
    }));

    res.status(200).json({
      success: true,
      bookings: formattedBookings
    });

  } catch (error) {
    console.error('Get user bookings error:', error);
    res.status(500).json({
      success: false,
      message: 'Failed to retrieve bookings'
    });
  }
};

exports.getUserBookings = getUserBookings;

/**
 * Internal helper: Clean up stale bookings (abandoned payment sessions)
 * Returns the count of cancelled bookings
 * Can be called internally without req/res
 */
const cleanUpStaleBookingsInternal = async () => {
  const STALE_THRESHOLD_MINUTES = 5;
  
  // Calculate cutoff time (5 minutes ago)
  const cutoffTime = new Date();
  cutoffTime.setMinutes(cutoffTime.getMinutes() - STALE_THRESHOLD_MINUTES);

  // Find all pending bookings older than 5 minutes
  const staleBookings = await Booking.findAll({
    where: {
      status: 'Pending_Payment',
      created_at: {
        [Op.lt]: cutoffTime
      }
    },
    include: [{ model: Room, as: 'room', attributes: ['name', 'type'] }]
  });

  if (staleBookings.length === 0) {
    return 0;
  }

  // Update all stale bookings to Cancelled
  await Booking.update(
    { status: 'Cancelled' },
    {
      where: {
        status: 'Pending_Payment',
        created_at: {
          [Op.lt]: cutoffTime
        }
      }
    }
  );

  console.log(`üßπ Auto-cleanup: Cancelled ${staleBookings.length} abandoned booking(s):`);
  staleBookings.forEach(booking => {
    console.log(`   - ${booking.reference_code} (${booking.room?.name || booking.room?.type})`);
  });

  return staleBookings.length;
};

/**
 * Cancel stale bookings (abandoned payment sessions)
 * GET /api/payment/cleanup-stale-bookings
 */
exports.cancelStaleBookings = async (req, res) => {
  try {
    const cutoffTime = new Date();
    cutoffTime.setMinutes(cutoffTime.getMinutes() - 5);

    console.log(`üßπ Starting stale booking cleanup...`);
    console.log(`‚è∞ Cutoff time: ${cutoffTime.toISOString()}`);

    const cancelledCount = await cleanUpStaleBookingsInternal();

    if (cancelledCount === 0) {
      console.log(`‚ú® No stale bookings found.`);
      return res.status(200).json({
        success: true,
        message: 'No stale bookings to clean up',
        cancelled: 0
      });
    }

    // Get the list of cancelled bookings for response
    const cancelledBookings = await Booking.findAll({
      where: {
        status: 'Cancelled',
        updated_at: {
          [Op.gte]: new Date(Date.now() - 10000) // Last 10 seconds
        }
      },
      attributes: ['reference_code'],
      limit: cancelledCount
    });

    const referencesCancelled = cancelledBookings.map(b => b.reference_code);

    res.status(200).json({
      success: true,
      message: `Successfully cancelled ${cancelledCount} abandoned booking(s)`,
      cancelled: cancelledCount,
      bookings: referencesCancelled
    });

  } catch (error) {
    console.error('‚ùå Stale booking cleanup error:', error);
    res.status(500).json({
      success: false,
      message: 'Failed to clean up stale bookings'
    });
  }
};

// Export the internal helper for use in other controllers
exports.cleanUpStaleBookingsInternal = cleanUpStaleBookingsInternal;
</file>

<file path="controllers/roomController.js">
const { Room, RoomImage, Booking } = require('../models');
const { Op } = require('sequelize');
const sequelize = require('../config/database');
const { cleanUpStaleBookingsInternal } = require('./paymentController');

// Get all rooms - Returns one representative per room type
exports.getAllRooms = async (req, res) => {
  try {
    console.log('=== GET ALL ROOMS ===');
    
    const rooms = await Room.findAll({
      where: {
        status: ['Available', 'Occupied'] // Exclude rooms under maintenance or dirty
      },
      include: [{
        model: RoomImage,
        as: 'images',
        required: false // Left join (rooms without images won't be excluded)
      }],
      order: [['type', 'ASC'], ['base_rate_3hr', 'ASC']] // Order by type, then price
    });

    console.log(`Found ${rooms.length} physical rooms in database`);

    // Group rooms by type and return only one representative per type
    const roomsByType = {};
    
    rooms.forEach(room => {
      const type = room.type;
      // Keep the first room of each type (which will have the lowest rate due to ordering)
      if (!roomsByType[type]) {
        roomsByType[type] = room;
        console.log(`  - Type "${type}": Using ${room.room_number} as representative`);
      }
    });

    console.log(`Grouped into ${Object.keys(roomsByType).length} unique room types`);

    // Format rooms for frontend - generic slugs per type
    const formattedRooms = Object.values(roomsByType).map(room => {
      const genericSlug = room.type.toLowerCase() + '-room';
      
      return {
        id: genericSlug,              // ‚úÖ Generic slug (e.g., "standard-room")
        name: `${room.type} Room`,    // ‚úÖ Generic name (e.g., "Standard Room")
        slug: genericSlug,
        tagline: room.tagline || '',
        description: room.description || '',
        capacity: room.capacity || '2 Adults',
        size: room.size || '25m¬≤',
        rates: {
          '3h': parseFloat(room.base_rate_3hr),
          '6h': parseFloat(room.base_rate_6hr),
          '12h': parseFloat(room.base_rate_12hr),
          '24h': parseFloat(room.base_rate_24hr)
        },
        amenities: room.amenities || [],
        image: room.image || 'bg-gray-300',
        images: room.images ? room.images.map(img => ({
          id: img.image_id,
          path: img.image_path,
          isPrimary: img.is_primary
        })) : [],
        type: room.type
      };
    });

    console.log(`Returning ${formattedRooms.length} room type(s) to frontend`);
    formattedRooms.forEach(r => console.log(`  - ${r.id} (${r.name})`));

    res.status(200).json({
      success: true,
      rooms: formattedRooms
    });
  } catch (error) {
    console.error('Get all rooms error:', error);
    console.error('Error name:', error.name);
    console.error('Error message:', error.message);
    console.error('Error stack:', error.stack);
    res.status(500).json({
      success: false,
      message: 'Server error. Please try again later.'
    });
  }
};

// Get room by slug or ID - Accepts generic slugs (e.g., "standard-room")
exports.getRoomBySlug = async (req, res) => {
  try {
    const { slug } = req.params;

    // Map generic slug to room type
    const slugToType = {
      'value-room': 'Value',
      'standard-room': 'Standard',
      'deluxe-room': 'Deluxe',
      'superior-room': 'Superior',
      'suite-room': 'Suite'
    };

    let room;
    
    // First, try to find by the exact slug (for backward compatibility)
    room = await Room.findOne({
      where: { slug },
      include: [{
        model: RoomImage,
        as: 'images',
        required: false
      }]
    });

    // If not found, try to map generic slug to type
    if (!room && slugToType[slug]) {
      room = await Room.findOne({
        where: { type: slugToType[slug] },
        include: [{
          model: RoomImage,
          as: 'images',
          required: false
        }]
      });
    }

    // If still not found, try direct type match
    if (!room) {
      const type = slug.charAt(0).toUpperCase() + slug.slice(1).replace('-room', '');
      room = await Room.findOne({
        where: { type: type },
        include: [{
          model: RoomImage,
          as: 'images',
          required: false
        }]
      });
    }

    if (!room) {
      return res.status(404).json({
        success: false,
        message: 'Room not found'
      });
    }

    // Format room for frontend with generic slug
    const genericSlug = room.type.toLowerCase() + '-room';
    
    const formattedRoom = {
      id: genericSlug,
      name: `${room.type} Room`,
      slug: genericSlug,
      tagline: room.tagline || '',
      description: room.description || '',
      capacity: room.capacity || '2 Adults',
      size: room.size || '25m¬≤',
      rates: {
        '3h': parseFloat(room.base_rate_3hr),
        '6h': parseFloat(room.base_rate_6hr),
        '12h': parseFloat(room.base_rate_12hr),
        '24h': parseFloat(room.base_rate_24hr)
      },
      amenities: room.amenities || [],
      image: room.image || 'bg-gray-300',
      images: room.images ? room.images.map(img => ({
        id: img.image_id,
        path: img.image_path,
        isPrimary: img.is_primary
      })) : [],
      type: room.type
    };

    res.status(200).json({
      success: true,
      room: formattedRoom
    });
  } catch (error) {
    console.error('Get room by slug error:', error);
    res.status(500).json({
      success: false,
      message: 'Server error. Please try again later.'
    });
  }
};

// Get available rooms (for booking)
exports.getAvailableRooms = async (req, res) => {
  try {
    const rooms = await Room.findAll({
      where: {
        status: 'Available'
      },
      include: [{
        model: RoomImage,
        as: 'images',
        required: false
      }],
      order: [['base_rate_3hr', 'ASC']]
    });

    const formattedRooms = rooms.map(room => ({
      id: room.slug || room.type.toLowerCase(),
      name: room.name || `${room.type} Room`,
      slug: room.slug || room.type.toLowerCase(),
      type: room.type,
      rates: {
        '3h': parseFloat(room.base_rate_3hr),
        '6h': parseFloat(room.base_rate_6hr),
        '12h': parseFloat(room.base_rate_12hr),
        '24h': parseFloat(room.base_rate_24hr)
      },
      roomNumber: room.room_number,
      images: room.images ? room.images.map(img => ({
        id: img.image_id,
        path: img.image_path,
        isPrimary: img.is_primary
      })) : []
    }));

    res.status(200).json({
      success: true,
      rooms: formattedRooms
    });
  } catch (error) {
    console.error('Get available rooms error:', error);
    res.status(500).json({
      success: false,
      message: 'Server error. Please try again later.'
    });
  }
};

// Check room availability - Finds ALL available physical rooms of the requested type
exports.checkAvailability = async (req, res) => {
  try {
    console.log('=== CHECK AVAILABILITY ===');
    
    // üßπ SELF-CLEANING: Auto-sweep stale bookings before checking availability
    await cleanUpStaleBookingsInternal();

    const { slug } = req.params;
    const { checkInDate, checkInTime, duration } = req.query;

    console.log(`Requested slug: ${slug}`);
    console.log(`Check-in: ${checkInDate} ${checkInTime}, Duration: ${duration}`);

    // Validate required parameters
    if (!checkInDate || !checkInTime || !duration) {
      return res.status(400).json({
        success: false,
        message: 'Missing required parameters: checkInDate, checkInTime, duration'
      });
    }

    // Validate 5-minute increment rule
    const [hours, minutes] = checkInTime.split(':').map(Number);
    if (minutes % 5 !== 0) {
      return res.status(400).json({
        success: false,
        message: 'Check-in time must be in 5-minute increments (e.g., 14:00, 14:05, 14:10)'
      });
    }

    // Map generic slug to room type
    const slugToType = {
      'value-room': 'Value',
      'standard-room': 'Standard',
      'deluxe-room': 'Deluxe',
      'superior-room': 'Superior',
      'suite-room': 'Suite'
    };

    let roomType = slugToType[slug];
    
    // If slug not in map, try to extract type from slug
    if (!roomType) {
      roomType = slug.charAt(0).toUpperCase() + slug.slice(1).replace('-room', '');
    }

    // Find ALL physical rooms of this type
    const roomsOfType = await Room.findAll({
      where: { 
        type: roomType,
        status: ['Available', 'Occupied'] // Exclude maintenance/dirty rooms
      }
    });

    console.log(`Found ${roomsOfType.length} physical rooms of type "${roomType}"`);

    if (roomsOfType.length === 0) {
      return res.status(404).json({
        success: false,
        message: 'Room type not found'
      });
    }

    // Parse duration to hours
    const durationHours = parseInt(duration.replace('h', ''));
    
    // Create check-in and check-out datetime
    const checkIn = new Date(`${checkInDate}T${checkInTime}`);
    const checkOut = new Date(checkIn.getTime() + (durationHours * 60 * 60 * 1000));

    // Get Booking model
    const Booking = sequelize.models.Booking || require('../models/Booking');
    const CLEANING_GAP_MINUTES = 30;

    // Collect ALL available rooms (not just the first one)
    const availableRooms = [];

    console.log(`Checking availability for each physical room...`);

    for (const room of roomsOfType) {
      // Check if room is currently locked (soft lock)
      if (room.lock_expiration && new Date(room.lock_expiration) > new Date()) {
        console.log(`  - Room ${room.room_number}: LOCKED (expires ${room.lock_expiration})`);
        continue; // Skip this room, try next
      }

      // Check for conflicting bookings for this specific physical room
      const conflictingBookings = await Booking.findAll({
        where: {
          room_id: room.room_id,
          status: {
            [Op.in]: ['Pending_Payment', 'Confirmed', 'Checked_In']
          }
        }
      });

      // Check each existing booking for conflicts, accounting for 30-min cleaning time
      let hasConflict = false;
      for (const booking of conflictingBookings) {
        const existingCheckIn = new Date(booking.check_in_time);
        const existingCheckOut = new Date(booking.check_out_time);
        
        // Add 30-minute cleaning buffer to checkout time
        const existingCheckOutWithCleaning = new Date(existingCheckOut.getTime() + CLEANING_GAP_MINUTES * 60000);
        
        // Check for overlap:
        // 1. New booking starts before existing ends (with cleaning)
        // 2. New booking ends after existing starts
        const hasOverlap = (
          checkIn < existingCheckOutWithCleaning && 
          checkOut > existingCheckIn
        );
        
        if (hasOverlap) {
          hasConflict = true;
          break;
        }
      }

      // If no conflict found, add this room to available list
      if (!hasConflict) {
        availableRooms.push({
          id: room.room_id,              // Physical room database ID for booking
          number: room.room_number,      // Display number (e.g., "201S")
          name: room.name                // Full name (e.g., "Standard Room 201S")
        });
        console.log(`  - Room ${room.room_number}: AVAILABLE ‚úì`);
      } else {
        console.log(`  - Room ${room.room_number}: BOOKED (conflict found)`);
      }
    }

    console.log(`Result: ${availableRooms.length} room(s) available`);

    // Get a representative room for display info (first one of the type)
    const representativeRoom = roomsOfType[0];
    const genericSlug = representativeRoom.type.toLowerCase() + '-room';

    // Return availability status with ALL available rooms
    if (availableRooms.length > 0) {
      res.status(200).json({
        success: true,
        available: true,
        message: `${availableRooms.length} ${representativeRoom.type} Room${availableRooms.length > 1 ? 's' : ''} available for your selected time!`,
        availableRooms: availableRooms, // ‚úÖ Array with { id, number, name }
        roomId: availableRooms[0].id, // First available room ID (for backward compatibility)
        room: {
          id: genericSlug,
          name: `${representativeRoom.type} Room`,
          type: representativeRoom.type,
          image: representativeRoom.image,
          rates: {
            '3h': parseFloat(representativeRoom.base_rate_3hr),
            '6h': parseFloat(representativeRoom.base_rate_6hr),
            '12h': parseFloat(representativeRoom.base_rate_12hr),
            '24h': parseFloat(representativeRoom.base_rate_24hr)
          },
          capacity: representativeRoom.capacity,
          tagline: representativeRoom.tagline
        },
        booking: {
          checkInDate,
          checkInTime,
          checkIn: checkIn.toISOString(),
          checkOut: checkOut.toISOString(),
          duration,
          durationHours
        }
      });
    } else {
      res.status(200).json({
        success: true,
        available: false,
        message: `All ${representativeRoom.type} rooms are fully booked for the selected time. Please note: rooms require a 30-minute cleaning period between bookings.`,
        availableRooms: [], // Empty list
        room: {
          id: genericSlug,
          name: `${representativeRoom.type} Room`,
          type: representativeRoom.type,
          image: representativeRoom.image
        },
        booking: {
          checkInDate,
          checkInTime,
          checkIn: checkIn.toISOString(),
          checkOut: checkOut.toISOString(),
          duration,
          durationHours
        }
      });
    }
  } catch (error) {
    console.error('Check availability error:', error);
    res.status(500).json({
      success: false,
      message: 'Server error while checking availability.'
    });
  }
};
</file>

<file path="guidelines-server.md">
# Server - Backend Coding Standards

## 1. Server Architecture

### Framework
- **Node.js** with **Express.js** web framework
- Entry point: `server.js`

### Database
- **MySQL** via **XAMPP** (default config)
- **Sequelize ORM** for database operations
- Connection config: `config/database.js`
- Environment-based settings: `config/config.json`

### Directory Structure

| Folder         | Purpose                                          |
| -------------- | ------------------------------------------------ |
| `config/`      | Database connection, environment validation      |
| `controllers/` | Request handlers and business logic              |
| `middleware/`  | Auth guards, rate limiters, sanitization         |
| `models/`      | Sequelize model definitions                      |
| `routes/`      | Express route definitions                        |
| `scripts/`     | Test scripts (security, API contract, etc.)      |
| `utils/`       | Shared utilities (AppError class)                |

---

## 2. Model Definition Pattern (‚ö†Ô∏è CRITICAL)

### Pattern Used: Standalone Instance Pattern

This project uses `sequelize.define()` with a **shared Sequelize instance** imported directly into each model file.

> ‚ö†Ô∏è **DO NOT** use the Factory Pattern (`module.exports = (sequelize) => {}`)  
> ‚ö†Ô∏è **DO NOT** use `Model.init()` with class syntax (except `RoomImage.js` which is a legacy exception)

### ‚úÖ Correct Pattern (User.js, Room.js, Booking.js)

```javascript
const { DataTypes } = require('sequelize');
const sequelize = require('../config/database');

const ModelName = sequelize.define('ModelName', {
  // field definitions
}, {
  tableName: 'table_name',
  timestamps: false,
  underscored: true
});

// Associations defined as static method
ModelName.associate = function(models) {
  ModelName.hasMany(models.OtherModel, { ... });
};

module.exports = ModelName;
```

### ‚ùå Wrong Pattern (DO NOT USE)

```javascript
// WRONG: Factory pattern
module.exports = (sequelize, DataTypes) => {
  const Model = sequelize.define('Model', { ... });
  return Model;
};

// WRONG: Class-based with init (except RoomImage legacy)
class Model extends Model {
  static init(sequelize) { ... }
}
```

### Model Loader (`models/index.js`)

The loader handles both patterns for backwards compatibility but **new models must use the standalone pattern**:

```javascript
if (typeof modelDef === 'function' && !modelDef.options) {
  // Factory Pattern (legacy)
  model = modelDef(sequelize, Sequelize.DataTypes);
} else {
  // Standalone Pattern (preferred)
  model = modelDef;
}
```

---

## 3. Database Schema

### Core Tables

| Table          | Primary Key   | Description                    |
| -------------- | ------------- | ------------------------------ |
| `users`        | `user_id`     | Guest and staff accounts       |
| `rooms`        | `room_id`     | Physical room inventory        |
| `bookings`     | `booking_id`  | Reservation records            |
| `room_images`  | `image_id`    | Room photo gallery             |

### Relationships

```
User (1) ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ< Booking (M)
                       ‚îÇ
Room (1) ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ<‚îò
  ‚îÇ
  ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ< RoomImage (M)
```

| Association                    | Type       | Foreign Key |
| ------------------------------ | ---------- | ----------- |
| `Room.hasMany(Booking)`        | One-to-Many | `room_id`   |
| `Room.hasMany(RoomImage)`      | One-to-Many | `room_id`   |
| `Booking.belongsTo(Room)`      | Many-to-One | `room_id`   |
| `RoomImage.belongsTo(Room)`    | Many-to-One | `room_id`   |

### Column Naming Convention

- Database uses **snake_case**: `user_id`, `first_name`, `check_in_time`
- Sequelize maps via `field` property and `underscored: true` option
- API responses maintain **snake_case** (no camelCase transformation)

### Key Fields Reference

**users:**
`user_id`, `first_name`, `last_name`, `email`, `phone`, `password`, `role`, `created_at`, `updated_at`

**rooms:**
`room_id`, `room_number`, `type`, `name`, `slug`, `tagline`, `description`, `capacity`, `size`, `amenities` (JSON), `image`, `base_rate_3hr`, `base_rate_6hr`, `base_rate_12hr`, `base_rate_24hr`, `status`, `lock_expiration`, `locked_by_session_id`

**bookings:**
`booking_id`, `guest_id`, `room_id`, `reference_code`, `checkout_session_id`, `check_in_time`, `check_out_time`, `duration_hours`, `source`, `status`, `total_amount`, `created_at`

**room_images:**
`image_id`, `room_id`, `image_path`, `is_primary`, `created_at`

---

## 4. Controller Patterns

### Structure

Controllers live in `controllers/` and handle:
- Request parsing
- Business logic
- Database operations
- Response formatting

### Async/Await Pattern

```javascript
exports.controllerMethod = async (req, res) => {
  try {
    // 1. Extract and validate input
    const { param } = req.body;
    
    // 2. Perform database operation
    const result = await Model.findAll({ where: { ... } });
    
    // 3. Return response
    res.status(200).json({ success: true, data: result });
    
  } catch (error) {
    console.error('Error:', error);
    res.status(500).json({ error: 'Internal server error' });
  }
};
```

### Error Handling

- Use `AppError` class for operational errors
- Global error handler in `controllers/errorController.js`
- Development mode: Full stack traces
- Production mode: Sanitized error messages

```javascript
const AppError = require('../utils/AppError');

// Throw operational error
throw new AppError('Resource not found', 404);
```

### Transaction Pattern (for multi-step operations)

```javascript
const sequelize = require('../config/database');

const result = await sequelize.transaction(async (t) => {
  const record = await Model.create({ ... }, { transaction: t });
  await OtherModel.update({ ... }, { transaction: t });
  return record;
});
```

---

## 5. API Structure

### Base URL

```
/api
```

> Note: No version prefix (`/api/v1`). Routes are directly under `/api/`.

### Route Files

| File                | Mount Point       |
| ------------------- | ----------------- |
| `authRoutes.js`     | `/api/auth`       |
| `roomRoutes.js`     | `/api/rooms`      |
| `paymentRoutes.js`  | `/api/payment`    |

### Key Endpoints

#### Authentication (`/api/auth`)

| Method | Endpoint            | Auth     | Description              |
| ------ | ------------------- | -------- | ------------------------ |
| POST   | `/signup`           | Public   | Register new user        |
| POST   | `/login`            | Public   | Login, returns JWT       |
| PUT    | `/profile`          | Required | Update user profile      |
| PUT    | `/change-password`  | Required | Change password          |
| GET    | `/stats`            | Required | Get user statistics      |

#### Rooms (`/api/rooms`)

| Method | Endpoint                      | Auth   | Description                    |
| ------ | ----------------------------- | ------ | ------------------------------ |
| GET    | `/`                           | Public | Get all rooms (by type)        |
| GET    | `/available`                  | Public | Get available rooms            |
| GET    | `/:slug`                      | Public | Get room by slug               |
| GET    | `/:slug/check-availability`   | Public | Check room availability        |

#### Payments (`/api/payment`)

| Method | Endpoint                 | Auth     | Description                    |
| ------ | ------------------------ | -------- | ------------------------------ |
| POST   | `/create-checkout`       | Required | Create PayMongo session        |
| POST   | `/webhook`               | Internal | PayMongo webhook handler       |
| GET    | `/verify/:referenceCode` | Public   | Verify payment status          |
| GET    | `/booking/:referenceCode`| Public   | Get booking details            |
| GET    | `/my-bookings`           | Required | Get user's bookings            |
| GET    | `/cleanup-stale-bookings`| Public   | Cancel abandoned bookings      |

---

## 6. Security Middleware

### Applied Globally (server.js)

| Middleware            | Purpose                                    |
| --------------------- | ------------------------------------------ |
| `cors()`              | Restrict origins (dev: localhost:5173/5174)|
| `express.json()`      | Body parsing with 10KB limit               |
| `sanitizeRequestBody` | Strip HTML/XSS from inputs                 |
| `apiLimiter`          | 100 requests per 15 min per IP             |

### Route-Specific

| Middleware     | Applied To            | Limit                    |
| -------------- | --------------------- | ------------------------ |
| `authLimiter`  | `/auth/login`, `/signup` | 5 requests per 15 min |
| `verifyToken`  | Protected routes      | JWT validation           |

---

## 7. Environment Variables

### Required (validated on startup)

```env
JWT_SECRET=your-secret-key
DB_NAME=balai_almeda_db
DB_USER=root
DB_PASS=
DB_HOST=localhost
PAYMONGO_TEST_SECRET_KEY=sk_test_...
PAYMONGO_WEBHOOK_SECRET=whsk_...
FRONTEND_URL=http://localhost:5173
```

### Optional

```env
PORT=3000
NODE_ENV=development
PAYMONGO_IS_LIVE=false
IMS_URL=http://localhost:5174
```

---

## 8. Coding Rules

### Mandatory Patterns

| Rule | Description |
| ---- | ----------- |
| ‚úÖ Use `async/await` | No callbacks or raw `.then()` chains in controllers |
| ‚úÖ Use `try/catch` | Wrap all async operations |
| ‚úÖ Use `AppError` | For operational errors with status codes |
| ‚úÖ Use transactions | For multi-model write operations |
| ‚úÖ Validate input | Check required fields before DB operations |
| ‚ùå No `console.log` in production | Use conditional logging |

### Response Format

```javascript
// Success
res.status(200).json({
  success: true,
  data: { ... }
});

// Error
res.status(400).json({
  success: false,
  message: 'Error description'
});
```

### Import Order

```javascript
// 1. Node.js built-ins
const crypto = require('crypto');

// 2. External packages
const express = require('express');
const axios = require('axios');

// 3. Internal modules
const sequelize = require('../config/database');
const { Room, Booking } = require('../models');
const AppError = require('../utils/AppError');
```

---

*This document defines the backend standards for the server package. All AI-assisted code generation must adhere to these patterns, especially the Model Definition Style.*
</file>

<file path="middleware/about.txt">
Middleware functions act as "bridges" or security guards that execute during the request-response cycle before a request reaches your controller.

Authentication & Authorization: Verifies if a user is logged in (checking for a valid JWT token) or has the right permissions (e.g., Guest vs. Admin) to access a specific route.

Data Validation: Checks if the data sent by a user (like in a Login form) is in the correct format before the server tries to process it.

Global Tasks: Handles common tasks like logging every request that comes in or parsing JSON data so the server can read it.
</file>

<file path="middleware/authMiddleware.js">
const jwt = require('jsonwebtoken');

// üîí SECURITY: JWT Secret (Section 2.1)
// No fallback - server will fail if JWT_SECRET is not set (validated on startup)
const JWT_SECRET = process.env.JWT_SECRET;

// Middleware to verify JWT token
exports.verifyToken = (req, res, next) => {
  try {
    // Get token from header
    const authHeader = req.headers.authorization;
    
    if (!authHeader || !authHeader.startsWith('Bearer ')) {
      return res.status(401).json({ 
        success: false, 
        message: 'No token provided' 
      });
    }

    // Extract token
    const token = authHeader.substring(7); // Remove 'Bearer ' prefix

    // Verify token
    const decoded = jwt.verify(token, JWT_SECRET);
    
    // Attach user ID to request
    req.userId = decoded.id;
    req.userEmail = decoded.email;
    req.userRole = decoded.role;
    
    next();
  } catch (error) {
    if (error.name === 'JsonWebTokenError') {
      return res.status(401).json({ 
        success: false, 
        message: 'Invalid token' 
      });
    }
    if (error.name === 'TokenExpiredError') {
      return res.status(401).json({ 
        success: false, 
        message: 'Token expired. Please login again.' 
      });
    }
    return res.status(500).json({ 
      success: false, 
      message: 'Server error during authentication' 
    });
  }
};
</file>

<file path="middleware/rateLimiters.js">
/**
 * Rate Limiting Middleware (Section 2.5)
 * 
 * Protects against brute-force attacks, DDoS, and API abuse.
 * Implements different rate limits for general API access and authentication endpoints.
 */

const rateLimit = require('express-rate-limit');

/**
 * General API Rate Limiter
 * Applies to all API endpoints
 * 
 * Limit: 100 requests per 15 minutes per IP
 */
const apiLimiter = rateLimit({
  windowMs: 15 * 60 * 1000, // 15 minutes
  max: 100, // Limit each IP to 100 requests per windowMs
  message: {
    success: false,
    message: 'Too many requests from this IP, please try again later.'
  },
  standardHeaders: true, // Return rate limit info in the `RateLimit-*` headers
  legacyHeaders: false, // Disable the `X-RateLimit-*` headers
  
  // Custom handler for rate limit exceeded
  handler: (req, res) => {
    console.warn(`‚ö†Ô∏è SECURITY: Rate limit exceeded for IP ${req.ip} on ${req.path}`);
    res.status(429).json({
      success: false,
      message: 'Too many requests from this IP, please try again later.'
    });
  }
});

/**
 * Strict Authentication Rate Limiter
 * Applies only to login and signup endpoints
 * 
 * Limit: 5 requests per 15 minutes per IP
 * 
 * This strict limit prevents:
 * - Brute force password attacks
 * - Account enumeration
 * - Automated account creation
 */
const authLimiter = rateLimit({
  windowMs: 15 * 60 * 1000, // 15 minutes
  max: 5, // Limit each IP to 5 requests per windowMs
  message: {
    success: false,
    message: 'Too many authentication attempts, please try again after 15 minutes.'
  },
  standardHeaders: true, // Return rate limit info in the `RateLimit-*` headers
  legacyHeaders: false, // Disable the `X-RateLimit-*` headers
  
  // Skip successful requests from counting against the limit (optional)
  skipSuccessfulRequests: false, // Count all attempts, even successful ones
  
  // Custom handler for rate limit exceeded
  handler: (req, res) => {
    console.warn(`‚ö†Ô∏è SECURITY: Auth rate limit exceeded for IP ${req.ip} on ${req.path}`);
    res.status(429).json({
      success: false,
      message: 'Too many authentication attempts, please try again after 15 minutes.'
    });
  }
});

module.exports = {
  apiLimiter,
  authLimiter
};
</file>

<file path="middleware/sanitize.js">
/**
 * Input Sanitization Middleware (Section 2.4)
 * 
 * Sanitizes all string values in request body to prevent XSS attacks.
 * Strips HTML tags, script tags, and other potentially malicious content.
 */

const validator = require('validator');

/**
 * Recursively sanitize an object's string values
 * @param {any} obj - The object to sanitize
 * @returns {any} - Sanitized object
 */
function sanitizeObject(obj) {
  if (obj === null || obj === undefined) {
    return obj;
  }

  // Handle strings - strip HTML tags and trim
  if (typeof obj === 'string') {
    // Use validator to escape HTML, then strip tags
    let sanitized = validator.stripLow(obj); // Remove control characters
    sanitized = validator.escape(sanitized); // Escape HTML entities
    
    // Additionally, use a simple regex to remove any remaining HTML-like tags
    sanitized = sanitized.replace(/<[^>]*>/g, '');
    
    return sanitized.trim();
  }

  // Handle arrays - sanitize each element
  if (Array.isArray(obj)) {
    return obj.map(item => sanitizeObject(item));
  }

  // Handle objects - sanitize each property
  if (typeof obj === 'object') {
    const sanitized = {};
    for (const key in obj) {
      if (obj.hasOwnProperty(key)) {
        sanitized[key] = sanitizeObject(obj[key]);
      }
    }
    return sanitized;
  }

  // Return primitive values as-is (numbers, booleans)
  return obj;
}

/**
 * Express middleware to sanitize request body
 */
function sanitizeRequestBody(req, res, next) {
  if (req.body && typeof req.body === 'object') {
    // Log original vs sanitized for security monitoring (only in development)
    if (process.env.NODE_ENV !== 'production') {
      const hasUnsafeContent = JSON.stringify(req.body).includes('<') || 
                               JSON.stringify(req.body).includes('>') ||
                               JSON.stringify(req.body).includes('script');
      
      if (hasUnsafeContent) {
        console.warn('‚ö†Ô∏è SECURITY: Potentially unsafe content detected in request body - sanitizing...');
      }
    }

    // Sanitize the entire request body
    req.body = sanitizeObject(req.body);
  }

  next();
}

module.exports = sanitizeRequestBody;
</file>

<file path="models/Booking.js">
const { DataTypes } = require('sequelize');
const sequelize = require('../config/database');

const Booking = sequelize.define('Booking', {
  booking_id: {
    type: DataTypes.INTEGER,
    primaryKey: true,
    autoIncrement: true,
    field: 'booking_id'
  },
  guest_id: {
    type: DataTypes.INTEGER,
    allowNull: true, // Allow null for walk-in bookings
    field: 'guest_id'
  },
  room_id: {
    type: DataTypes.INTEGER,
    allowNull: false,
    field: 'room_id'
  },
  reference_code: {
    type: DataTypes.STRING(20),
    unique: true,
    field: 'reference_code'
  },
  checkout_session_id: {
    type: DataTypes.STRING(255),
    allowNull: true,
    field: 'checkout_session_id'
  },
  check_in_time: {
    type: DataTypes.DATE,
    allowNull: true,
    field: 'check_in_time'
  },
  check_out_time: {
    type: DataTypes.DATE,
    allowNull: true,
    field: 'check_out_time'
  },
  duration_hours: {
    type: DataTypes.INTEGER,
    allowNull: false,
    field: 'duration_hours'
  },
  adults_count: {
    type: DataTypes.INTEGER,
    allowNull: false,
    defaultValue: 1,
    field: 'adults_count'
  },
  children_count: {
    type: DataTypes.INTEGER,
    allowNull: false,
    defaultValue: 0,
    field: 'children_count'
  },
  child_ages: {
    type: DataTypes.JSON,
    allowNull: true,
    field: 'child_ages'
  },
  source: {
    type: DataTypes.ENUM('Web', 'Walk_in'),
    defaultValue: 'Web'
  },
  status: {
    type: DataTypes.ENUM('Pending_Payment', 'Confirmed', 'Checked_In', 'Completed', 'Cancelled'),
    defaultValue: 'Pending_Payment'
  },
  total_amount: {
    type: DataTypes.DECIMAL(10, 2),
    allowNull: false,
    field: 'total_amount'
  },
  created_at: {
    type: DataTypes.DATE,
    defaultValue: DataTypes.NOW,
    field: 'created_at'
  }
}, {
  tableName: 'bookings',
  timestamps: false,
  underscored: true
});

// Define associations
Booking.associate = function(models) {
  Booking.belongsTo(models.Room, {
    foreignKey: 'room_id',
    targetKey: 'room_id',
    as: 'room'
  });
};

module.exports = Booking;
</file>

<file path="models/index.js">
'use strict';

const fs = require('fs');
const path = require('path');
const Sequelize = require('sequelize');
const process = require('process');
const basename = path.basename(__filename);
const db = {};

// 1. Load the shared Sequelize instance
const sequelize = require('../config/database');

fs.readdirSync(__dirname)
  .filter(file => {
    return (
      file.indexOf('.') !== 0 &&
      file !== basename &&
      file.slice(-3) === '.js' &&
      file.indexOf('.test.js') === -1
    );
  })
  .forEach(file => {
    // 2. Load the Model Definition
    const modelDef = require(path.join(__dirname, file));
    
    // 3. Handle Export Styles (The Fix for the Crash)
    let model;
    if (typeof modelDef === 'function' && !modelDef.options) {
        // Factory Pattern: module.exports = (sequelize) => {}
        model = modelDef(sequelize, Sequelize.DataTypes);
    } else {
        // Class Pattern: module.exports = ModelClass
        model = modelDef; 
    }

    // 4. Register Model
    if (model && model.name) {
        db[model.name] = model;
    }
  });

// 5. Setup Associations
Object.keys(db).forEach(modelName => {
  if (db[modelName].associate) {
    db[modelName].associate(db);
  }
});

db.sequelize = sequelize;
db.Sequelize = Sequelize;

module.exports = db;
</file>

<file path="models/Room.js">
const { DataTypes } = require('sequelize');
const sequelize = require('../config/database');

const Room = sequelize.define('Room', {
  room_id: {
    type: DataTypes.INTEGER,
    primaryKey: true,
    autoIncrement: true,
    field: 'room_id'
  },
  room_number: {
    type: DataTypes.STRING(10),
    allowNull: false,
    unique: true,
    field: 'room_number'
  },
  type: {
    type: DataTypes.ENUM('Value', 'Standard', 'Deluxe', 'Superior', 'Suite'),
    allowNull: false
  },
  name: {
    type: DataTypes.STRING(100),
    allowNull: true
  },
  slug: {
    type: DataTypes.STRING(100),
    allowNull: true,
    unique: true
  },
  tagline: {
    type: DataTypes.STRING(255),
    allowNull: true
  },
  description: {
    type: DataTypes.TEXT,
    allowNull: true
  },
  capacity: {
    type: DataTypes.STRING(50),
    allowNull: true
  },
  size: {
    type: DataTypes.STRING(20),
    allowNull: true
  },
  amenities: {
    type: DataTypes.JSON,
    allowNull: true,
    get() {
      const rawValue = this.getDataValue('amenities');
      return rawValue ? (typeof rawValue === 'string' ? JSON.parse(rawValue) : rawValue) : [];
    }
  },
  image: {
    type: DataTypes.STRING(255),
    allowNull: true
  },
  base_rate_3hr: {
    type: DataTypes.DECIMAL(10, 2),
    allowNull: false,
    field: 'base_rate_3hr'
  },
  base_rate_6hr: {
    type: DataTypes.DECIMAL(10, 2),
    allowNull: false,
    field: 'base_rate_6hr'
  },
  base_rate_12hr: {
    type: DataTypes.DECIMAL(10, 2),
    allowNull: false,
    field: 'base_rate_12hr'
  },
  base_rate_24hr: {
    type: DataTypes.DECIMAL(10, 2),
    allowNull: false,
    field: 'base_rate_24hr'
  },
  status: {
    type: DataTypes.ENUM('Available', 'Occupied', 'Dirty', 'Maintenance'),
    defaultValue: 'Available'
  },
  lock_expiration: {
    type: DataTypes.DATE,
    allowNull: true,
    field: 'lock_expiration'
  },
  locked_by_session_id: {
    type: DataTypes.STRING(255),
    allowNull: true,
    field: 'locked_by_session_id'
  }
}, {
  tableName: 'rooms',
  timestamps: false,
  underscored: true
});

// Define associations
Room.associate = function(models) {
  Room.hasMany(models.Booking, {
    foreignKey: 'room_id',
    sourceKey: 'room_id',
    as: 'bookings'
  });
  
  Room.hasMany(models.RoomImage, {
    foreignKey: 'room_id',
    sourceKey: 'room_id',
    as: 'images'
  });
};

module.exports = Room;
</file>

<file path="models/RoomImage.js">
const { Model, DataTypes } = require('sequelize');
const sequelize = require('../config/database');

class RoomImage extends Model {}

RoomImage.init(
  {
    image_id: {
      type: DataTypes.INTEGER,
      primaryKey: true,
      autoIncrement: true,
      field: 'image_id',
    },
    room_id: {
      type: DataTypes.INTEGER,
      allowNull: false,
      field: 'room_id',
      references: {
        model: 'rooms',
        key: 'room_id',
      },
      onDelete: 'CASCADE',
    },
    image_path: {
      type: DataTypes.STRING(255),
      allowNull: false,
      field: 'image_path',
    },
    is_primary: {
      type: DataTypes.BOOLEAN,
      defaultValue: false,
      field: 'is_primary',
    },
    created_at: {
      type: DataTypes.DATE,
      allowNull: false,
      defaultValue: DataTypes.NOW,
      field: 'created_at',
    },
  },
  {
    sequelize,
    modelName: 'RoomImage',
    tableName: 'room_images',
    timestamps: false, // Using manual created_at field instead
    underscored: true,
  }
);

// Define associations
RoomImage.associate = function(models) {
  RoomImage.belongsTo(models.Room, {
    foreignKey: 'room_id',
    targetKey: 'room_id',
    as: 'room'
  });
};

module.exports = RoomImage;
</file>

<file path="models/User.js">
const { DataTypes } = require('sequelize');
const sequelize = require('../config/database');

const User = sequelize.define('User', {
  user_id: {
    type: DataTypes.INTEGER,
    primaryKey: true,
    autoIncrement: true,
    field: 'user_id'
  },
  first_name: {
    type: DataTypes.STRING(100),
    allowNull: false,
    field: 'first_name'
  },
  last_name: {
    type: DataTypes.STRING(100),
    allowNull: false,
    field: 'last_name'
  },
  email: {
    type: DataTypes.STRING(100),
    allowNull: false,
    unique: true,
    validate: {
      isEmail: true
    }
  },
  phone: {
    type: DataTypes.STRING(20),
    allowNull: true,
    field: 'phone'
  },
  password: {
    type: DataTypes.STRING(255),
    allowNull: false
  },
  role: {
    type: DataTypes.ENUM('Guest', 'Admin', 'FrontDesk', 'Housekeeping', 'Manager'),
    defaultValue: 'Guest'
  },
  created_at: {
    type: DataTypes.DATE,
    defaultValue: DataTypes.NOW,
    field: 'created_at'
  },
  updated_at: {
    type: DataTypes.DATE,
    defaultValue: DataTypes.NOW,
    field: 'updated_at'
  }
}, {
  tableName: 'users',
  timestamps: true,
  createdAt: 'created_at',
  updatedAt: 'updated_at',
  underscored: true
});

module.exports = User;
</file>

<file path="package.json">
{
  "name": "server",
  "version": "1.0.0",
  "main": "server.js",
  "scripts": {
    "start": "nodemon server.js"
  },
  "keywords": [],
  "author": "",
  "license": "ISC",
  "description": "",
  "dependencies": {
    "axios": "^1.13.2",
    "bcryptjs": "^3.0.3",
    "body-parser": "^2.2.2",
    "cors": "^2.8.5",
    "dotenv": "^17.2.3",
    "express": "^5.2.1",
    "express-rate-limit": "^8.2.1",
    "express-rate-limiter": "^1.3.1",
    "jsonwebtoken": "^9.0.3",
    "mysql2": "^3.16.1",
    "nodemon": "^3.1.11",
    "sequelize": "^6.37.7",
    "validator": "^13.15.26"
  },
  "devDependencies": {
    "sequelize-cli": "^6.6.5"
  }
}
</file>

<file path="routes/about.txt">
The routes folder serves as the "map" or directory for your API.

Endpoint Definition: It defines the URL paths (e.g., /api/auth/login or /api/public/rooms) and the HTTP methods (GET, POST, PUT, DELETE) the server should listen for.

Connecting Routes to Logic: The route file doesn't contain the actual logic; instead, it simply tells Express: "If someone hits this URL, call this specific function in the Controller".

Applying Security: This is where you "attach" middleware to specific routes, ensuring that certain endpoints are protected by authentication.
</file>

<file path="routes/authRoutes.js">
const express = require('express');
const router = express.Router();
const authController = require('../controllers/authController');
const authMiddleware = require('../middleware/authMiddleware');
const { authLimiter } = require('../middleware/rateLimiters');

// üîí SECURITY: Strict rate limiting on authentication endpoints (Section 2.5)
// POST /api/auth/signup - Register new user (5 attempts per 15 min)
router.post('/signup', authLimiter, authController.signup);

// POST /api/auth/login - Login user (5 attempts per 15 min)
router.post('/login', authLimiter, authController.login);

// PUT /api/auth/profile - Update user profile (protected)
router.put('/profile', authMiddleware.verifyToken, authController.updateProfile);

// PUT /api/auth/change-password - Change user password (protected)
router.put('/change-password', authMiddleware.verifyToken, authController.changePassword);

// GET /api/auth/stats - Get user stats (protected)
router.get('/stats', authMiddleware.verifyToken, authController.getUserStats);

module.exports = router;
</file>

<file path="routes/devRoutes.js">
const express = require('express');
const router = express.Router();
const devController = require('../controllers/devController');

/**
 * Development Routes
 * 
 * ‚ö†Ô∏è WARNING: These routes should ONLY be available in development/testing environments
 * They provide tools to simulate payment states and debug bookings
 * 
 * Mount this router with an environment check in server.js:
 * if (process.env.NODE_ENV !== 'production') {
 *   app.use('/api/dev', devRoutes);
 * }
 */

/**
 * POST /api/dev/simulate-payment/:referenceCode
 * Simulate a payment success or failure for testing
 * 
 * @param {string} referenceCode - Booking reference code (e.g., BKG-ABC123)
 * @body {
 *   status: 'paid' | 'failed'
 * }
 * 
 * @example
 * POST /api/dev/simulate-payment/BKG-ABC123
 * Body: { "status": "paid" }
 * 
 * This will update the booking status from Pending_Payment to Confirmed
 */
router.post('/simulate-payment/:referenceCode', devController.simulatePayment);

/**
 * GET /api/dev/pending-bookings
 * Get all bookings with status 'Pending_Payment'
 * 
 * Useful for finding which bookings need payment simulation
 * 
 * @example
 * GET /api/dev/pending-bookings
 */
router.get('/pending-bookings', devController.getPendingBookings);

/**
 * GET /api/dev/all-bookings
 * Get all bookings (or filter by status)
 * 
 * @query {string} status - Optional: Filter by status (Pending_Payment, Confirmed, etc.)
 * @query {number} limit - Optional: Max results (default: 50)
 * 
 * @example
 * GET /api/dev/all-bookings
 * GET /api/dev/all-bookings?status=Confirmed
 * GET /api/dev/all-bookings?limit=10
 */
router.get('/all-bookings', devController.getAllBookings);

module.exports = router;
</file>

<file path="routes/paymentRoutes.js">
const express = require('express');
const router = express.Router();
const paymentController = require('../controllers/paymentController');
const { verifyToken } = require('../middleware/authMiddleware');

// POST /api/payment/create-checkout - Create PayMongo checkout session
// ‚ö†Ô∏è SECURITY: Now requires authentication to prevent guest_id manipulation
router.post('/create-checkout', verifyToken, paymentController.createCheckoutSession);

// POST /api/payment/webhook - Handle PayMongo webhook events
router.post('/webhook', paymentController.handleWebhook);

// GET /api/payment/verify/:referenceCode - Verify payment status
router.get('/verify/:referenceCode', paymentController.verifyPayment);

// GET /api/payment/booking/:referenceCode - Get booking details by reference code
router.get('/booking/:referenceCode', paymentController.getBookingByReference);

// GET /api/payment/my-bookings - Get all bookings for authenticated user
router.get('/my-bookings', verifyToken, paymentController.getUserBookings);

// GET /api/payment/cleanup-stale-bookings - Cancel abandoned bookings older than 5 minutes
router.get('/cleanup-stale-bookings', paymentController.cancelStaleBookings);

module.exports = router;
</file>

<file path="routes/roomRoutes.js">
const express = require('express');
const router = express.Router();
const roomController = require('../controllers/roomController');

// GET /api/rooms - Get all rooms
router.get('/', roomController.getAllRooms);

// GET /api/rooms/available - Get only available rooms
router.get('/available', roomController.getAvailableRooms);

// GET /api/rooms/:slug/check-availability - Check room availability
router.get('/:slug/check-availability', roomController.checkAvailability);

// GET /api/rooms/:slug - Get room by slug
router.get('/:slug', roomController.getRoomBySlug);

module.exports = router;
</file>

<file path="scripts/test-api-contract.js">
/**
 * API CONTRACT VERIFICATION TEST
 * 
 * Purpose: Verify the exact structure and property naming (casing) of API responses
 * This test is "unbiased" - it doesn't assume snake_case or camelCase, it just reports what it finds.
 * 
 * Run: node server/scripts/test-api-contract.js
 */

require('dotenv').config();
const axios = require('axios');

const BASE_URL = process.env.API_BASE_URL || 'http://localhost:3000';
const API_URL = `${BASE_URL}/api`;

// üé® Console colors
const colors = {
  reset: '\x1b[0m',
  bright: '\x1b[1m',
  green: '\x1b[32m',
  red: '\x1b[31m',
  yellow: '\x1b[33m',
  blue: '\x1b[34m',
  cyan: '\x1b[36m',
  magenta: '\x1b[35m'
};

// Test user credentials (must exist in database)
const TEST_USER = {
  email: 'fabila@gmail.com',
  password: 'Cholo12345@'
};

let authToken = null;

/**
 * Log with color
 */
function log(message, color = colors.reset) {
  console.log(`${color}${message}${colors.reset}`);
}

/**
 * Print a header
 */
function printHeader(title) {
  log('\n' + '='.repeat(80), colors.cyan);
  log(`  ${title}`, colors.cyan + colors.bright);
  log('='.repeat(80), colors.cyan);
}

/**
 * Print object keys with their types
 */
function printObjectStructure(obj, indent = '') {
  for (const [key, value] of Object.entries(obj)) {
    const type = Array.isArray(value) ? 'array' : typeof value;
    const displayValue = type === 'object' && value !== null ? '{...}' : 
                        type === 'array' ? `[${value.length} items]` :
                        type === 'string' ? `"${value.substring(0, 30)}${value.length > 30 ? '...' : ''}"` :
                        value;
    
    log(`${indent}${key}: ${colors.yellow}${type}${colors.reset} = ${displayValue}`, colors.reset);
    
    if (type === 'object' && value !== null && !Array.isArray(value)) {
      printObjectStructure(value, indent + '  ');
    }
  }
}

/**
 * Test 1: Login and get auth token
 */
async function testLogin() {
  printHeader('TEST 1: Login');
  
  try {
    const response = await axios.post(`${API_URL}/auth/login`, TEST_USER);
    
    if (response.data.success && response.data.token) {
      authToken = response.data.token;
      log('‚úÖ Login successful', colors.green);
      log(`   Token: ${authToken.substring(0, 20)}...`, colors.reset);
      return true;
    } else {
      log('‚ùå Login failed - No token received', colors.red);
      return false;
    }
  } catch (error) {
    log(`‚ùå Login error: ${error.response?.data?.message || error.message}`, colors.red);
    return false;
  }
}

/**
 * Test 2: Get My Bookings and analyze response structure
 */
async function testMyBookingsContract() {
  printHeader('TEST 2: API Contract - GET /api/payment/my-bookings');
  
  try {
    const response = await axios.get(`${API_URL}/payment/my-bookings`, {
      headers: {
        'Authorization': `Bearer ${authToken}`
      }
    });
    
    log('‚úÖ Request successful', colors.green);
    log(`   Status: ${response.status}`, colors.reset);
    
    // Analyze top-level response structure
    log('\nüì¶ TOP-LEVEL RESPONSE STRUCTURE:', colors.cyan);
    printObjectStructure(response.data);
    
    // Check if bookings array exists
    if (!response.data.bookings) {
      log('\n‚ö†Ô∏è  WARNING: No "bookings" property found in response', colors.yellow);
      return false;
    }
    
    if (!Array.isArray(response.data.bookings)) {
      log('\n‚ùå ERROR: "bookings" is not an array', colors.red);
      return false;
    }
    
    log(`\nüìä Found ${response.data.bookings.length} booking(s)`, colors.cyan);
    
    if (response.data.bookings.length === 0) {
      log('‚ö†Ô∏è  No bookings to analyze. Create a test booking first.', colors.yellow);
      return true;
    }
    
    // Analyze first booking structure
    const firstBooking = response.data.bookings[0];
    log('\nüîç FIRST BOOKING STRUCTURE:', colors.cyan);
    printObjectStructure(firstBooking);
    
    // Contract verification - check for camelCase vs snake_case
    log('\nüß™ CONTRACT VERIFICATION:', colors.magenta);
    
    const camelCaseKeys = [
      'bookingId', 'referenceCode', 'guestName', 'checkInTime', 
      'checkOutTime', 'totalAmount', 'roomName', 'roomId', 'paymentStatus'
    ];
    
    const snakeCaseKeys = [
      'booking_id', 'reference_code', 'guest_name', 'check_in_time',
      'check_out_time', 'total_amount', 'room_name', 'room_id', 'payment_status'
    ];
    
    let camelCaseCount = 0;
    let snakeCaseCount = 0;
    
    log('\n  Checking for camelCase keys:', colors.cyan);
    camelCaseKeys.forEach(key => {
      const exists = key in firstBooking;
      camelCaseCount += exists ? 1 : 0;
      const symbol = exists ? '‚úÖ' : '‚ùå';
      log(`    ${symbol} ${key}: ${exists ? 'FOUND' : 'MISSING'}`, exists ? colors.green : colors.red);
    });
    
    log('\n  Checking for snake_case keys:', colors.cyan);
    snakeCaseKeys.forEach(key => {
      const exists = key in firstBooking;
      snakeCaseCount += exists ? 1 : 0;
      const symbol = exists ? '‚ö†Ô∏è' : '‚úÖ';
      log(`    ${symbol} ${key}: ${exists ? 'FOUND (unexpected)' : 'NOT FOUND (expected)'}`, exists ? colors.yellow : colors.green);
    });
    
    // Final verdict
    log('\nüìã CONTRACT VERDICT:', colors.cyan + colors.bright);
    
    if (camelCaseCount > snakeCaseCount) {
      log(`  ‚úÖ Backend is using CAMELCASE (${camelCaseCount}/${camelCaseKeys.length} keys found)`, colors.green);
      log(`  ‚úÖ Frontend should use: booking.referenceCode, booking.checkInTime, etc.`, colors.green);
    } else if (snakeCaseCount > camelCaseCount) {
      log(`  ‚ö†Ô∏è  Backend is using SNAKE_CASE (${snakeCaseCount}/${snakeCaseKeys.length} keys found)`, colors.yellow);
      log(`  ‚ö†Ô∏è  Frontend should use: booking.reference_code, booking.check_in_time, etc.`, colors.yellow);
    } else {
      log(`  ‚ö†Ô∏è  MIXED CASING DETECTED - This may cause bugs!`, colors.yellow);
    }
    
    // Sample data access examples
    log('\nüí° CORRECT DATA ACCESS EXAMPLES:', colors.cyan);
    log(`  Reference Code: ${firstBooking.referenceCode ?? firstBooking.reference_code ?? 'N/A'}`, colors.reset);
    log(`  Guest Name: ${firstBooking.guestName ?? firstBooking.guest_name ?? 'N/A'}`, colors.reset);
    log(`  Check-in Time: ${firstBooking.checkInTime ?? firstBooking.check_in_time ?? 'N/A'}`, colors.reset);
    log(`  Total Amount: ${firstBooking.totalAmount ?? firstBooking.total_amount ?? 'N/A'}`, colors.reset);
    log(`  Room Name: ${firstBooking.roomName ?? firstBooking.room_name ?? firstBooking.room?.name ?? 'N/A'}`, colors.reset);
    
    return true;
    
  } catch (error) {
    log(`‚ùå Request failed: ${error.response?.data?.message || error.message}`, colors.red);
    if (error.response?.status === 401) {
      log('   Hint: Authentication failed - token may be invalid', colors.yellow);
    }
    return false;
  }
}

/**
 * Test 3: Get Booking by Reference and analyze structure
 */
async function testBookingByReferenceContract() {
  printHeader('TEST 3: API Contract - GET /api/payment/verify/:referenceCode');
  
  try {
    // First, get a booking to get a reference code
    const bookingsResponse = await axios.get(`${API_URL}/payment/my-bookings`, {
      headers: { 'Authorization': `Bearer ${authToken}` }
    });
    
    if (!bookingsResponse.data.bookings || bookingsResponse.data.bookings.length === 0) {
      log('‚ö†Ô∏è  No bookings available to test. Skipping.', colors.yellow);
      return true;
    }
    
    const referenceCode = bookingsResponse.data.bookings[0].referenceCode ?? 
                         bookingsResponse.data.bookings[0].reference_code;
    
    if (!referenceCode) {
      log('‚ùå Could not extract reference code from booking', colors.red);
      return false;
    }
    
    log(`   Testing with reference: ${referenceCode}`, colors.cyan);
    
    // Now test the verify endpoint
    const response = await axios.get(`${API_URL}/payment/verify/${referenceCode}`);
    
    log('‚úÖ Request successful', colors.green);
    
    log('\nüì¶ VERIFY RESPONSE STRUCTURE:', colors.cyan);
    printObjectStructure(response.data);
    
    if (response.data.booking) {
      log('\nüîç BOOKING OBJECT STRUCTURE:', colors.cyan);
      printObjectStructure(response.data.booking);
    }
    
    return true;
    
  } catch (error) {
    log(`‚ùå Request failed: ${error.response?.data?.message || error.message}`, colors.red);
    return false;
  }
}

/**
 * Main test runner
 */
async function runContractTests() {
  log('\n' + '‚ñà'.repeat(80), colors.magenta);
  log('  API CONTRACT VERIFICATION TEST SUITE', colors.magenta + colors.bright);
  log('  Purpose: Verify exact API response structure (snake_case vs camelCase)', colors.magenta);
  log('‚ñà'.repeat(80) + '\n', colors.magenta);
  
  const results = {
    total: 0,
    passed: 0,
    failed: 0
  };
  
  // Test 1: Login
  results.total++;
  if (await testLogin()) {
    results.passed++;
  } else {
    results.failed++;
    log('\n‚ùå Cannot proceed without authentication', colors.red);
    printSummary(results);
    return;
  }
  
  // Test 2: My Bookings Contract
  results.total++;
  if (await testMyBookingsContract()) {
    results.passed++;
  } else {
    results.failed++;
  }
  
  // Test 3: Verify Booking Contract
  results.total++;
  if (await testBookingByReferenceContract()) {
    results.passed++;
  } else {
    results.failed++;
  }
  
  // Print summary
  printSummary(results);
}

/**
 * Print test summary
 */
function printSummary(results) {
  printHeader('TEST SUMMARY');
  
  log(`Total Tests: ${results.total}`, colors.cyan);
  log(`Passed: ${results.passed}`, colors.green);
  log(`Failed: ${results.failed}`, results.failed > 0 ? colors.red : colors.green);
  
  if (results.failed === 0) {
    log('\n‚úÖ ALL TESTS PASSED! API contract is verified.', colors.green + colors.bright);
  } else {
    log('\n‚ùå SOME TESTS FAILED. Review the output above.', colors.red + colors.bright);
  }
  
  log('\n' + '='.repeat(80) + '\n', colors.cyan);
}

// Run the test suite
runContractTests().catch(error => {
  log(`\nüí• Fatal error: ${error.message}`, colors.red);
  console.error(error);
  process.exit(1);
});
</file>

<file path="scripts/test-child-fee-calculation.js">
/**
 * Child Fee Calculation Test Script
 * 
 * This script simulates the exact logic used in the server to calculate child fees.
 * Use this to verify the math is working correctly.
 * 
 * Run: node server/scripts/test-child-fee-calculation.js
 */

const colors = {
  green: '\x1b[32m',
  red: '\x1b[31m',
  yellow: '\x1b[33m',
  blue: '\x1b[34m',
  cyan: '\x1b[36m',
  reset: '\x1b[0m'
};

function log(color, message) {
  console.log(`${color}${message}${colors.reset}`);
}

function testChildFeeCalculation(testName, basePrice, childAges, expectedTotal) {
  console.log('\n' + '‚îÄ'.repeat(70));
  log(colors.cyan, `TEST: ${testName}`);
  console.log('‚îÄ'.repeat(70));
  
  console.log(`Base Room Price: ‚Ç±${basePrice}`);
  console.log(`Children: ${childAges.length}`);
  console.log(`Ages: [${childAges.join(', ')}]`);
  console.log('');
  
  // Simulate the exact server logic
  let childAddOnPrice = 0;
  
  for (let i = 0; i < childAges.length; i++) {
    const age = childAges[i];
    console.log(`Child ${i + 1}: Age ${age}`);
    
    if (age >= 7 && age <= 13) {
      childAddOnPrice += 150;
      console.log(`   ‚Üí CHARGEABLE (‚Ç±150) | Running total: ‚Ç±${childAddOnPrice}`);
    } else {
      console.log(`   ‚Üí FREE (age 0-6)`);
    }
  }
  
  const calculatedTotal = basePrice + childAddOnPrice;
  
  console.log('');
  console.log(`üí∞ CALCULATION:`);
  console.log(`   Base:       ‚Ç±${basePrice.toFixed(2)}`);
  console.log(`   Child fees: ‚Ç±${childAddOnPrice.toFixed(2)}`);
  console.log(`   ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ`);
  console.log(`   TOTAL:      ‚Ç±${calculatedTotal.toFixed(2)}`);
  console.log('');
  
  if (calculatedTotal === expectedTotal) {
    log(colors.green, `‚úÖ PASS: Total matches expected ‚Ç±${expectedTotal.toFixed(2)}`);
    return true;
  } else {
    log(colors.red, `‚ùå FAIL: Expected ‚Ç±${expectedTotal.toFixed(2)}, got ‚Ç±${calculatedTotal.toFixed(2)}`);
    return false;
  }
}

function testDataParsing(testName, rawInput, expectedArray) {
  console.log('\n' + '‚îÄ'.repeat(70));
  log(colors.cyan, `PARSING TEST: ${testName}`);
  console.log('‚îÄ'.repeat(70));
  
  console.log(`Raw Input:`, rawInput);
  console.log(`Type:`, typeof rawInput);
  
  let childAges = [];
  
  // Simulate the exact server parsing logic
  if (Array.isArray(rawInput)) {
    console.log(`[PARSING] Input is array`);
    childAges = rawInput
      .map(age => {
        const parsed = parseInt(age);
        console.log(`   - Parsing "${age}" ‚Üí ${parsed}`);
        return parsed;
      })
      .filter(age => !isNaN(age));
  } else if (typeof rawInput === 'string') {
    console.log(`[PARSING] Input is string: "${rawInput}"`);
    childAges = rawInput
      .split(',')
      .map(age => {
        const trimmed = age.trim();
        const parsed = parseInt(trimmed);
        console.log(`   - Parsing "${trimmed}" ‚Üí ${parsed}`);
        return parsed;
      })
      .filter(age => !isNaN(age));
  } else if (typeof rawInput === 'number') {
    console.log(`[PARSING] Input is number: ${rawInput}`);
    childAges = [parseInt(rawInput)];
  }
  
  console.log(`\nParsed Result:`, childAges);
  console.log(`Expected:`, expectedArray);
  
  const matches = JSON.stringify(childAges) === JSON.stringify(expectedArray);
  
  if (matches) {
    log(colors.green, `‚úÖ PASS: Parsing successful`);
    return true;
  } else {
    log(colors.red, `‚ùå FAIL: Parsing mismatch`);
    return false;
  }
}

function runAllTests() {
  console.clear();
  log(colors.blue, '\nüß™ CHILD FEE CALCULATION - TEST SUITE\n');
  
  let passCount = 0;
  let failCount = 0;
  
  // ========== PARSING TESTS ==========
  log(colors.yellow, '‚ïê'.repeat(70));
  log(colors.yellow, 'SECTION 1: DATA PARSING TESTS');
  log(colors.yellow, '‚ïê'.repeat(70));
  
  const parsingTests = [
    ['Array of integers', [8, 12], [8, 12]],
    ['Array of strings', ['8', '12'], [8, 12]],
    ['Comma-separated string', '8,12', [8, 12]],
    ['String with spaces', '8, 12', [8, 12]],
    ['Single number', 8, [8]],
    ['Single string', '8', [8]],
    ['Three values', [5, 9, 11], [5, 9, 11]],
    ['Mixed valid/invalid', ['8', 'abc', '12'], [8, 12]]
  ];
  
  parsingTests.forEach(([name, input, expected]) => {
    if (testDataParsing(name, input, expected)) {
      passCount++;
    } else {
      failCount++;
    }
  });
  
  // ========== FEE CALCULATION TESTS ==========
  log(colors.yellow, '\n\n' + '‚ïê'.repeat(70));
  log(colors.yellow, 'SECTION 2: FEE CALCULATION TESTS');
  log(colors.yellow, '‚ïê'.repeat(70));
  
  const basePrice = 500; // Standard room 3h
  
  const calculationTests = [
    ['No children', basePrice, [], 500],
    ['Young children (free)', basePrice, [3, 5], 500],
    ['Older children (both chargeable)', basePrice, [7, 10], 800],
    ['Mixed ages', basePrice, [4, 12], 650],
    ['Edge: Age 6 (free)', basePrice, [6], 500],
    ['Edge: Age 7 (charged)', basePrice, [7], 650],
    ['Edge: Age 13 (charged)', basePrice, [13], 650],
    ['Single chargeable child', basePrice, [9], 650],
    ['All free (0-6)', basePrice, [0, 2, 4, 6], 500],
    ['All chargeable (7-13)', basePrice, [7, 13], 800]
  ];
  
  calculationTests.forEach(([name, base, ages, expected]) => {
    if (testChildFeeCalculation(name, base, ages, expected)) {
      passCount++;
    } else {
      failCount++;
    }
  });
  
  // ========== SUMMARY ==========
  console.log('\n\n' + '‚ïê'.repeat(70));
  log(colors.blue, 'üìä TEST SUMMARY');
  console.log('‚ïê'.repeat(70));
  
  log(colors.green, `‚úÖ Passed: ${passCount}`);
  if (failCount > 0) {
    log(colors.red, `‚ùå Failed: ${failCount}`);
  }
  
  const totalTests = passCount + failCount;
  const passRate = ((passCount / totalTests) * 100).toFixed(1);
  
  console.log(`\nTotal: ${totalTests} tests`);
  console.log(`Pass Rate: ${passRate}%`);
  
  if (failCount === 0) {
    log(colors.green, '\nüéâ ALL TESTS PASSED!\n');
  } else {
    log(colors.red, '\n‚ö†Ô∏è  SOME TESTS FAILED - Review the output above\n');
  }
  
  // ========== USAGE EXAMPLES ==========
  console.log('‚ïê'.repeat(70));
  log(colors.blue, 'üí° USAGE EXAMPLES FOR YOUR API');
  console.log('‚ïê'.repeat(70));
  
  console.log(`
Example API Request Body:

{
  "roomSlug": "standard-room",
  "checkInDate": "2024-06-01",
  "checkInTime": "14:00",
  "duration": "3",
  "guestInfo": {
    "firstName": "John",
    "lastName": "Doe",
    "email": "john@example.com",
    "phone": "09171234567",
    "adults": 2,
    "children": 2,
    "childAges": [6, 10]  ‚Üê Can be array, string, or number
  }
}

Valid childAges formats:
  - [8, 12]       (array of numbers)
  - ["8", "12"]   (array of strings)
  - "8,12"        (comma-separated string)
  - "8, 12"       (with spaces)
  - 8             (single number)
  - "8"           (single string)

Expected Server Logs:
  üë∂ [CHILD AGES] Raw childAges from request: [6, 10]
  üë∂ [CHILD AGES] Type: object
  üë∂ [PARSING] Input is array
     - Parsing "6" ‚Üí 6
     - Parsing "10" ‚Üí 10
  üë∂ [PARSED AGES] Result: [6, 10]
  
  üí∞ [PRICE CALC STEP 2] Calculating child fees...
     Child 1: Age 6
        ‚Üí FREE (age 0-6)
     Child 2: Age 10
        ‚Üí CHARGEABLE (‚Ç±150) | Running total: ‚Ç±150
  
  üë∂ [CHILD POLICY SUMMARY]
     Total Children: 2
     Ages: [6, 10]
     Chargeable Children (7-13): 1
     Total Child Add-on Fee: ‚Ç±150
  
  üí∞ [PRICE CALC STEP 3] FINAL CALCULATION:
     Base Room Rate: ‚Ç±500.00
     Child Add-on:   ‚Ç±150.00
     ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
     TOTAL:          ‚Ç±650.00
  
  üîê Math Check: { base: 500, childFees: 150, total: 650 }
  `);
  
  console.log('‚ïê'.repeat(70));
  log(colors.blue, 'üîç DEBUGGING TIPS');
  console.log('‚ïê'.repeat(70));
  
  console.log(`
If child fees are still showing as ‚Ç±0:

1. Check server logs for these markers:
   üë∂ [CHILD AGES] Raw childAges from request:
   üë∂ [PARSING] Input is...
   üí∞ [PRICE CALC STEP 2] Calculating child fees...

2. Common issues:
   ‚ùå childAges is undefined ‚Üí Check frontend is sending the data
   ‚ùå childAges is empty array ‚Üí Check parsing logic
   ‚ùå Age validation fails ‚Üí Check age is 0-13
   ‚ùå Count mismatch ‚Üí Check array length matches children count

3. Test with curl:
   curl -X POST http://localhost:3000/api/payment/create-checkout \\
     -H "Content-Type: application/json" \\
     -H "Authorization: Bearer YOUR_TOKEN" \\
     -d '{
       "roomSlug": "standard-room",
       "checkInDate": "2024-06-01",
       "checkInTime": "14:00",
       "duration": "3",
       "guestInfo": {
         "firstName": "Test",
         "lastName": "User",
         "email": "test@example.com",
         "phone": "09171234567",
         "adults": 2,
         "children": 2,
         "childAges": [6, 10]
       }
     }'

4. Check database:
   SELECT reference_code, children_count, child_ages, total_amount
   FROM bookings
   ORDER BY created_at DESC
   LIMIT 1;
   
   Expected: child_ages = [6, 10], total_amount = 650.00
  `);
  
  console.log('‚ïê'.repeat(70));
  console.log('');
}

// Run the test suite
runAllTests();
</file>

<file path="scripts/test-child-policy.js">
/**
 * Child Policy End-to-End Test Script
 * 
 * This script tests the child policy implementation by simulating
 * API calls to the backend and verifying the responses.
 * 
 * Run: node server/scripts/test-child-policy.js
 */

const axios = require('axios');

const API_BASE_URL = 'http://localhost:3000/api';
const colors = {
  green: '\x1b[32m',
  red: '\x1b[31m',
  yellow: '\x1b[33m',
  blue: '\x1b[34m',
  reset: '\x1b[0m'
};

function log(color, message) {
  console.log(`${color}${message}${colors.reset}`);
}

function pass(message) {
  log(colors.green, `‚úÖ PASS: ${message}`);
}

function fail(message) {
  log(colors.red, `‚ùå FAIL: ${message}`);
}

function info(message) {
  log(colors.blue, `‚ÑπÔ∏è  INFO: ${message}`);
}

function warn(message) {
  log(colors.yellow, `‚ö†Ô∏è  WARN: ${message}`);
}

async function testChildPolicyValidation() {
  console.log('\n' + '='.repeat(70));
  log(colors.blue, 'üß™ TEST SUITE: Child Policy Validation');
  console.log('='.repeat(70) + '\n');

  let passCount = 0;
  let failCount = 0;

  // Test 1: Reject invalid children count (> 2)
  try {
    info('Test 1: Reject children count > 2');
    const response = await axios.post(`${API_BASE_URL}/payment/create-checkout`, {
      roomSlug: 'standard-room',
      checkInDate: '2024-06-01',
      checkInTime: '14:00',
      duration: '3',
      totalAmount: 500,
      guestInfo: {
        firstName: 'Test',
        lastName: 'User',
        email: 'test@example.com',
        phone: '09171234567',
        adults: 2,
        children: 3,  // Invalid: > 2
        childAges: [5, 7, 10]
      }
    }, {
      headers: { Authorization: 'Bearer YOUR_TEST_TOKEN' }
    });
    
    fail('Should have rejected children count > 2');
    failCount++;
  } catch (error) {
    if (error.response && error.response.status === 400) {
      pass('Rejected invalid children count (> 2)');
      passCount++;
    } else {
      fail(`Unexpected error: ${error.message}`);
      failCount++;
    }
  }

  // Test 2: Reject invalid age (> 13)
  try {
    info('Test 2: Reject child age > 13');
    const response = await axios.post(`${API_BASE_URL}/payment/create-checkout`, {
      roomSlug: 'standard-room',
      checkInDate: '2024-06-01',
      checkInTime: '14:00',
      duration: '3',
      totalAmount: 500,
      guestInfo: {
        firstName: 'Test',
        lastName: 'User',
        email: 'test@example.com',
        phone: '09171234567',
        adults: 2,
        children: 1,
        childAges: [15]  // Invalid: > 13
      }
    }, {
      headers: { Authorization: 'Bearer YOUR_TEST_TOKEN' }
    });
    
    fail('Should have rejected child age > 13');
    failCount++;
  } catch (error) {
    if (error.response && error.response.status === 400) {
      pass('Rejected invalid child age (> 13)');
      passCount++;
    } else {
      fail(`Unexpected error: ${error.message}`);
      failCount++;
    }
  }

  // Test 3: Reject mismatch between children count and ages array length
  try {
    info('Test 3: Reject count/ages mismatch');
    const response = await axios.post(`${API_BASE_URL}/payment/create-checkout`, {
      roomSlug: 'standard-room',
      checkInDate: '2024-06-01',
      checkInTime: '14:00',
      duration: '3',
      totalAmount: 500,
      guestInfo: {
        firstName: 'Test',
        lastName: 'User',
        email: 'test@example.com',
        phone: '09171234567',
        adults: 2,
        children: 2,
        childAges: [7]  // Invalid: only 1 age for 2 children
      }
    }, {
      headers: { Authorization: 'Bearer YOUR_TEST_TOKEN' }
    });
    
    fail('Should have rejected count/ages mismatch');
    failCount++;
  } catch (error) {
    if (error.response && error.response.status === 400) {
      pass('Rejected count/ages mismatch');
      passCount++;
    } else {
      fail(`Unexpected error: ${error.message}`);
      failCount++;
    }
  }

  // Summary
  console.log('\n' + '-'.repeat(70));
  log(colors.blue, `üìä VALIDATION TEST RESULTS:`);
  pass(`${passCount} tests passed`);
  if (failCount > 0) {
    fail(`${failCount} tests failed`);
  }
  console.log('-'.repeat(70) + '\n');

  return { passCount, failCount };
}

async function testPriceCalculation() {
  console.log('\n' + '='.repeat(70));
  log(colors.blue, 'üß™ TEST SUITE: Child Pricing Calculation');
  console.log('='.repeat(70) + '\n');

  const testCases = [
    {
      name: 'No children',
      children: 0,
      childAges: [],
      expectedSurcharge: 0,
      description: 'Base rate only'
    },
    {
      name: 'Children aged 0-6 (free)',
      children: 2,
      childAges: [3, 5],
      expectedSurcharge: 0,
      description: 'No surcharge for ages 0-6'
    },
    {
      name: 'Children aged 7-13 (‚Ç±150 each)',
      children: 2,
      childAges: [7, 10],
      expectedSurcharge: 300,
      description: '‚Ç±150 √ó 2 children'
    },
    {
      name: 'Mixed ages',
      children: 2,
      childAges: [4, 12],
      expectedSurcharge: 150,
      description: 'Only 12-year-old charged'
    },
    {
      name: 'Edge case: age 6 (free)',
      children: 1,
      childAges: [6],
      expectedSurcharge: 0,
      description: 'Age 6 is still free'
    },
    {
      name: 'Edge case: age 7 (chargeable)',
      children: 1,
      childAges: [7],
      expectedSurcharge: 150,
      description: 'Age 7 starts charging'
    }
  ];

  info(`Testing ${testCases.length} pricing scenarios...`);
  console.log('');

  for (const testCase of testCases) {
    const { name, children, childAges, expectedSurcharge, description } = testCase;
    
    // Calculate surcharge using the same logic as backend
    const chargeableChildren = childAges.filter(age => age >= 7 && age <= 13).length;
    const calculatedSurcharge = chargeableChildren * 150;

    if (calculatedSurcharge === expectedSurcharge) {
      pass(`${name}: ‚Ç±${calculatedSurcharge} - ${description}`);
    } else {
      fail(`${name}: Expected ‚Ç±${expectedSurcharge}, got ‚Ç±${calculatedSurcharge}`);
    }
  }

  console.log('\n' + '-'.repeat(70));
  log(colors.green, '‚úÖ All pricing calculations verified');
  console.log('-'.repeat(70) + '\n');
}

async function testDatabaseSchema() {
  console.log('\n' + '='.repeat(70));
  log(colors.blue, 'üß™ TEST SUITE: Database Schema Verification');
  console.log('='.repeat(70) + '\n');

  info('This test requires manual SQL verification:');
  console.log('');
  
  console.log('Run the following SQL query:');
  console.log('');
  log(colors.yellow, 'SHOW COLUMNS FROM bookings WHERE Field = \'child_ages\';');
  console.log('');
  
  console.log('Expected result:');
  console.log('‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê');
  console.log('‚îÇ Field      ‚îÇ Type     ‚îÇ Null ‚îÇ Key ‚îÇ Default ‚îÇ Extra ‚îÇ');
  console.log('‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§');
  console.log('‚îÇ child_ages ‚îÇ longtext ‚îÇ YES  ‚îÇ     ‚îÇ NULL    ‚îÇ       ‚îÇ');
  console.log('‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò');
  console.log('');

  warn('Manual verification required - Check your database!');
  console.log('\n' + '-'.repeat(70) + '\n');
}

async function runAllTests() {
  console.clear();
  log(colors.blue, '\nüöÄ CHILD POLICY IMPLEMENTATION - TEST SUITE\n');
  
  warn('‚ö†Ô∏è  IMPORTANT: Make sure your backend server is running on http://localhost:3000');
  warn('‚ö†Ô∏è  IMPORTANT: Update the Authorization token in the test script');
  console.log('');

  // Run tests
  await testPriceCalculation();
  await testDatabaseSchema();
  
  // Note about API tests
  console.log('\n' + '='.repeat(70));
  log(colors.yellow, '‚ö†Ô∏è  API VALIDATION TESTS REQUIRE AUTHENTICATION');
  console.log('='.repeat(70));
  console.log('');
  info('To run API validation tests:');
  console.log('1. Login to the website and get your JWT token');
  console.log('2. Update the Authorization header in this script');
  console.log('3. Uncomment the line below:');
  console.log('');
  log(colors.yellow, '   // await testChildPolicyValidation();');
  console.log('');
  console.log('-'.repeat(70) + '\n');

  log(colors.green, '‚úÖ TEST SUITE COMPLETE\n');
  log(colors.blue, 'Next steps:');
  console.log('1. Verify database schema (SQL query above)');
  console.log('2. Test the booking flow manually in the browser');
  console.log('3. Check server logs for child policy messages');
  console.log('4. Review documentation: CHILD_POLICY_FINAL_VERIFICATION.md\n');
}

// Run the test suite
runAllTests().catch(error => {
  fail(`Test suite failed: ${error.message}`);
  console.error(error);
  process.exit(1);
});
</file>

<file path="scripts/test-data-integrity.js">
/**
 * üß™ DATA INTEGRITY & UX TEST SUITE
 * 
 * Tests Section 3.3 (Date Boundaries) and Section 2.8 (Centralized Error Handling)
 * 
 * This is an UNBIASED test script that verifies:
 * 1. Cannot book dates in the past (with 5-min grace period)
 * 2. Cannot book beyond 1 year in advance
 * 3. 404 errors return proper JSON format
 * 4. All errors follow consistent error response format
 * 
 * Run: node server/scripts/test-data-integrity.js
 */

require('dotenv').config();
const axios = require('axios');

const BASE_URL = process.env.API_BASE_URL || 'http://localhost:3000';
const API_URL = `${BASE_URL}/api`;

// üé® Console colors
const colors = {
  reset: '\x1b[0m',
  red: '\x1b[31m',
  green: '\x1b[32m',
  yellow: '\x1b[33m',
  cyan: '\x1b[36m',
  dim: '\x1b[2m'
};

// Test user credentials (must exist in database)
const TEST_USER = {
  email: 'testuser@example.com',
  password: 'TestPassword123!'
};

let authToken = null;

// Test results tracking
const results = {
  passed: 0,
  failed: 0,
  tests: []
};

/**
 * Helper: Print test result
 */
function logTest(testName, passed, expected, actual) {
  const status = passed 
    ? `${colors.green}‚úÖ PASS${colors.reset}` 
    : `${colors.red}‚ùå FAIL${colors.reset}`;
  
  console.log(`\n${status} ${testName}`);
  
  if (!passed) {
    console.log(`${colors.dim}Expected: ${expected}${colors.reset}`);
    console.log(`${colors.dim}Actual: ${actual}${colors.reset}`);
  }
  
  results.tests.push({ name: testName, passed });
  if (passed) results.passed++;
  else results.failed++;
}

/**
 * Helper: Format date for API (YYYY-MM-DD)
 */
function formatDate(date) {
  return date.toISOString().split('T')[0];
}

/**
 * Helper: Format time for API (HH:MM) with 5-minute rounding
 */
function formatTime(date) {
  const hours = String(date.getHours()).padStart(2, '0');
  // Round to nearest 5-minute increment
  const minutes = Math.round(date.getMinutes() / 5) * 5;
  const roundedMinutes = String(minutes).padStart(2, '0');
  return `${hours}:${roundedMinutes}`;
}

/**
 * Test 1: Login to get auth token
 */
async function testLogin() {
  console.log(`\n${colors.cyan}‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê${colors.reset}`);
  console.log(`${colors.cyan}TEST 1: Authentication${colors.reset}`);
  console.log(`${colors.cyan}‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê${colors.reset}`);
  
  try {
    const response = await axios.post(`${API_URL}/auth/login`, TEST_USER);
    
    if (response.data.token) {
      authToken = response.data.token;
      logTest('Login successful', true, 'JWT token', 'JWT token received');
      return true;
    } else {
      logTest('Login successful', false, 'JWT token', 'No token received');
      return false;
    }
  } catch (error) {
    console.error(`${colors.red}‚ùå Login failed: ${error.response?.data?.message || error.message}${colors.reset}`);
    console.error(`${colors.yellow}‚ö†Ô∏è  Please ensure test user exists with credentials:${colors.reset}`);
    console.error(`   Email: ${TEST_USER.email}`);
    console.error(`   Password: ${TEST_USER.password}`);
    return false;
  }
}

/**
 * Test 2: Booking with past date (should fail with 400)
 */
async function testPastDateBooking() {
  console.log(`\n${colors.cyan}‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê${colors.reset}`);
  console.log(`${colors.cyan}TEST 2: Past Date Validation${colors.reset}`);
  console.log(`${colors.cyan}‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê${colors.reset}`);
  
  // Create a date 1 hour in the past
  const pastDate = new Date();
  pastDate.setHours(pastDate.getHours() - 1);
  
  const bookingData = {
    roomSlug: 'deluxe-room',
    checkInDate: formatDate(pastDate),
    checkInTime: formatTime(pastDate),
    duration: '3',
    guestInfo: {
      firstName: 'Test',
      lastName: 'User',
      email: 'test@example.com',
      phone: '+63 912 345 6789'
    }
  };
  
  console.log(`${colors.dim}Attempting to book: ${bookingData.checkInDate} ${bookingData.checkInTime}${colors.reset}`);
  
  try {
    const response = await axios.post(
      `${API_URL}/payment/create-checkout`,
      bookingData,
      { headers: { Authorization: `Bearer ${authToken}` } }
    );
    
    // If we get here, the API accepted a past date (FAIL)
    logTest(
      'Reject past date booking',
      false,
      '400 Bad Request with "Cannot book dates in the past"',
      `${response.status} - Booking was accepted (security issue!)`
    );
  } catch (error) {
    const status = error.response?.status;
    const message = error.response?.data?.message;
    
    const isPassed = 
      status === 400 && 
      message && 
      message.toLowerCase().includes('past');
    
    logTest(
      'Reject past date booking',
      isPassed,
      '400 with "Cannot book dates in the past"',
      `${status} - "${message}"`
    );
  }
}

/**
 * Test 3: Booking beyond 1 year (should fail with 400)
 */
async function testFarFutureBooking() {
  console.log(`\n${colors.cyan}‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê${colors.reset}`);
  console.log(`${colors.cyan}TEST 3: Far Future Validation${colors.reset}`);
  console.log(`${colors.cyan}‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê${colors.reset}`);
  
  // Create a date 2 years in the future
  const farFuture = new Date();
  farFuture.setFullYear(farFuture.getFullYear() + 2);
  
  const bookingData = {
    roomSlug: 'deluxe-room',
    checkInDate: formatDate(farFuture),
    checkInTime: formatTime(farFuture),
    duration: '3',
    guestInfo: {
      firstName: 'Test',
      lastName: 'User',
      email: 'test@example.com',
      phone: '+63 912 345 6789'
    }
  };
  
  console.log(`${colors.dim}Attempting to book: ${bookingData.checkInDate} ${bookingData.checkInTime}${colors.reset}`);
  
  try {
    const response = await axios.post(
      `${API_URL}/payment/create-checkout`,
      bookingData,
      { headers: { Authorization: `Bearer ${authToken}` } }
    );
    
    // If we get here, the API accepted a far future date (FAIL)
    logTest(
      'Reject far future booking (>1 year)',
      false,
      '400 Bad Request with "Bookings limited to 1 year"',
      `${response.status} - Booking was accepted (should be limited)`
    );
  } catch (error) {
    const status = error.response?.status;
    const message = error.response?.data?.message;
    
    const isPassed = 
      status === 400 && 
      message && 
      (message.toLowerCase().includes('1 year') || message.toLowerCase().includes('advance'));
    
    logTest(
      'Reject far future booking (>1 year)',
      isPassed,
      '400 with "Bookings limited to 1 year in advance"',
      `${status} - "${message}"`
    );
  }
}

/**
 * Test 4: 404 Error Format (undefined route)
 */
async function test404ErrorFormat() {
  console.log(`\n${colors.cyan}‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê${colors.reset}`);
  console.log(`${colors.cyan}TEST 4: 404 Error Response Format${colors.reset}`);
  console.log(`${colors.cyan}‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê${colors.reset}`);
  
  try {
    await axios.get(`${API_URL}/this-route-does-not-exist`);
    
    // If we get here, route exists (unexpected)
    logTest(
      '404 returns JSON error',
      false,
      '404 with JSON error message',
      '200 - Route exists (unexpected)'
    );
  } catch (error) {
    const status = error.response?.status;
    const data = error.response?.data;
    
    const isJSON = data && typeof data === 'object';
    const hasMessage = isJSON && data.message;
    const isPassed = status === 404 && isJSON && hasMessage;
    
    logTest(
      '404 returns JSON error',
      isPassed,
      '404 with JSON {message: "..."}',
      `${status} - ${isJSON ? 'JSON response' : 'Non-JSON response'} - Message: "${data?.message}"`
    );
  }
}

/**
 * Test 5: Valid booking (should succeed)
 */
async function testValidBooking() {
  console.log(`\n${colors.cyan}‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê${colors.reset}`);
  console.log(`${colors.cyan}TEST 5: Valid Booking (Control Test)${colors.reset}`);
  console.log(`${colors.cyan}‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê${colors.reset}`);
  
  // Create a valid date (24 hours from now to avoid conflicts)
  const validDate = new Date();
  validDate.setHours(validDate.getHours() + 24);
  // Round to 5-minute increment
  validDate.setMinutes(Math.ceil(validDate.getMinutes() / 5) * 5);
  validDate.setSeconds(0);
  
  const bookingData = {
    roomSlug: 'value-room', // Use Value room to avoid conflicts with other tests
    checkInDate: formatDate(validDate),
    checkInTime: formatTime(validDate),
    duration: '3',
    guestInfo: {
      firstName: 'Test',
      lastName: 'User',
      email: 'test@example.com',
      phone: '+63 912 345 6789'
    }
  };
  
  console.log(`${colors.dim}Attempting to book: ${bookingData.checkInDate} ${bookingData.checkInTime}${colors.reset}`);
  
  try {
    const response = await axios.post(
      `${API_URL}/payment/create-checkout`,
      bookingData,
      { headers: { Authorization: `Bearer ${authToken}` } }
    );
    
    const hasCheckoutUrl = response.data?.checkoutUrl;
    const hasReference = response.data?.referenceCode;
    const isPassed = response.status === 200 && hasCheckoutUrl && hasReference;
    
    logTest(
      'Accept valid booking',
      isPassed,
      '200 with checkoutUrl and referenceCode',
      `${response.status} - ${hasCheckoutUrl ? 'Has checkout URL' : 'Missing URL'} - ${hasReference ? `Ref: ${response.data.referenceCode}` : 'No reference'}`
    );
  } catch (error) {
    const status = error.response?.status;
    const message = error.response?.data?.message;
    
    logTest(
      'Accept valid booking',
      false,
      '200 Success',
      `${status} - Error: "${message}"`
    );
  }
}

/**
 * Main test runner
 */
async function runTests() {
  console.log(`\n${colors.cyan}‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïó${colors.reset}`);
  console.log(`${colors.cyan}‚ïë       üß™ DATA INTEGRITY & UX TEST SUITE                   ‚ïë${colors.reset}`);
  console.log(`${colors.cyan}‚ïë       Testing Date Boundaries & Error Handling           ‚ïë${colors.reset}`);
  console.log(`${colors.cyan}‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù${colors.reset}`);
  console.log(`\n${colors.dim}API Base URL: ${BASE_URL}${colors.reset}`);
  
  // Step 1: Login
  const loginSuccess = await testLogin();
  if (!loginSuccess) {
    console.error(`\n${colors.red}‚ùå Cannot proceed without authentication${colors.reset}`);
    process.exit(1);
  }
  
  // Step 2-5: Run all data integrity tests
  await testPastDateBooking();
  await testFarFutureBooking();
  await test404ErrorFormat();
  await testValidBooking();
  
  // Summary
  console.log(`\n${colors.cyan}‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê${colors.reset}`);
  console.log(`${colors.cyan}TEST SUMMARY${colors.reset}`);
  console.log(`${colors.cyan}‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê${colors.reset}`);
  console.log(`${colors.green}‚úÖ Passed: ${results.passed}${colors.reset}`);
  console.log(`${colors.red}‚ùå Failed: ${results.failed}${colors.reset}`);
  console.log(`Total: ${results.tests.length}`);
  
  if (results.failed === 0) {
    console.log(`\n${colors.green}üéâ ALL TESTS PASSED! Data integrity is solid.${colors.reset}`);
    process.exit(0);
  } else {
    console.log(`\n${colors.red}‚ö†Ô∏è  SOME TESTS FAILED. Please review the implementation.${colors.reset}`);
    process.exit(1);
  }
}

// Run the test suite
runTests().catch(error => {
  console.error(`\n${colors.red}‚ùå Test suite crashed:${colors.reset}`, error.message);
  process.exit(1);
});
</file>

<file path="scripts/test-final-boss.js">
// server/scripts/test-final-boss.js
const crypto = require('crypto');
const axios = require('axios');
require('dotenv').config();

const BASE_URL = 'http://localhost:3000/api';
const WEBHOOK_SECRET = process.env.PAYMONGO_WEBHOOK_SECRET;

// Utils for colored logs
const log = (msg, color = '\x1b[0m') => console.log(color + msg + '\x1b[0m');
const GREEN = '\x1b[32m';
const RED = '\x1b[31m';
const YELLOW = '\x1b[33m';

// Helper to generate a signature
function generateSignature(payload) {
    return crypto
        .createHmac('sha256', WEBHOOK_SECRET)
        .update(JSON.stringify(payload))
        .digest('hex');
}

async function runTests() {
    log('\n‚öîÔ∏è  STARTING FINAL BOSS TESTS (Webhook & Race Condition)\n', YELLOW);

    // --- SETUP: Create User & Get Token ---
    let token;
    try {
        const email = `tester_${Date.now()}@example.com`;
        await axios.post(`${BASE_URL}/auth/signup`, {
            firstName: 'Race', lastName: 'Tester',
            email, phone: '09170000000', password: 'Password123!'
        });
        const loginRes = await axios.post(`${BASE_URL}/auth/login`, {
            email, password: 'Password123!'
        });
        token = loginRes.data.token;
        log('‚úÖ Setup: Test User Created & Logged In', GREEN);
    } catch (err) {
        log('‚ùå Setup Failed: ' + (err.response?.data?.message || err.message), RED);
        process.exit(1);
    }

    // --- TEST 1: Webhook Security ---
    log('\n--- Test 1: Webhook Security ---', YELLOW);
    
    // Case A: No Signature
    try {
        await axios.post(`${BASE_URL}/payment/webhook`, { type: 'test' });
        log('‚ùå FAIL: Accepted webhook without signature', RED);
    } catch (err) {
        if (err.response?.status === 401) log('‚úÖ PASS: Rejected missing signature', GREEN);
        else log(`‚ùå FAIL: Unexpected status ${err.response?.status}`, RED);
    }

    // Case B: Valid Signature
    try {
        const payload = { 
            data: { 
                attributes: { 
                    type: 'checkout_session.payment.paid',
                    data: { attributes: { checkout_session_id: 'test_session' } }
                } 
            } 
        };
        const signature = generateSignature(payload);
        
        await axios.post(`${BASE_URL}/payment/webhook`, payload, {
            headers: { 'paymongo-signature': signature }
        });
        log('‚úÖ PASS: Accepted valid signature', GREEN);
    } catch (err) {
        log(`‚ùå FAIL: Rejected valid signature (Status ${err.response?.status})`, RED);
        if(err.response?.status === 500) log('   (Note: 500 might mean logic inside webhook failed, but auth passed)', YELLOW);
    }

    // --- TEST 2: Race Condition (The Stress Test) ---
    log('\n--- Test 2: Race Condition (Double Booking) ---', YELLOW);
    log('üöÄ Firing 5 simultaneous booking requests for the SAME room...', YELLOW);

    const bookingPayload = {
        roomSlug: 'superior-room', // Ensure this room type exists in your DB
        checkInDate: '2026-12-25',
        checkInTime: '14:00',
        duration: '12',
        guestInfo: { firstName: 'Race', lastName: 'Test', email: 'race@test.com', phone: '09170000000' }
    };

    const requests = Array(5).fill().map(() => 
        axios.post(`${BASE_URL}/payment/create-checkout`, bookingPayload, {
            headers: { Authorization: `Bearer ${token}` }
        }).then(res => ({ status: res.status, data: res.data }))
          .catch(err => ({ status: err.response?.status, data: err.response?.data }))
    );

    const results = await Promise.all(requests);
    
    const successes = results.filter(r => r.status === 200).length;
    const conflicts = results.filter(r => r.status === 409 || r.status === 500).length; // 500 is ok if it's a lock timeout

    log(`\nResults: ${successes} Success, ${conflicts} Failed/Conflict`);

    if (successes === 1) {
        log('‚úÖ PASS: Exactly one booking succeeded. Race condition prevented.', GREEN);
    } else if (successes === 0) {
        log('‚ö†Ô∏è WARN: All failed. Check if room is available at all.', YELLOW);
    } else {
        log(`‚ùå FAIL: ${successes} bookings succeeded! Double booking detected!`, RED);
    }
}

runTests();
</file>

<file path="scripts/test-high-priority.js">
/**
 * High Priority Security Fixes - Verification Test Script
 * Balai Almeda Hotel System
 * 
 * Tests Sections 2.1, 2.4, 2.5:
 * - JWT Secret Cleanup
 * - Input Sanitization
 * - Rate Limiting
 * 
 * Run: node server/scripts/test-high-priority.js
 * (Ensure server is running on http://localhost:3000)
 */

const http = require('http');

// ANSI color codes for terminal output
const colors = {
  reset: '\x1b[0m',
  green: '\x1b[32m',
  red: '\x1b[31m',
  yellow: '\x1b[33m',
  cyan: '\x1b[36m',
  bold: '\x1b[1m'
};

/**
 * Make HTTP POST request
 */
function makeRequest(path, data) {
  return new Promise((resolve, reject) => {
    const postData = JSON.stringify(data);
    
    const options = {
      hostname: 'localhost',
      port: 3000,
      path: path,
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
        'Content-Length': Buffer.byteLength(postData)
      }
    };

    const req = http.request(options, (res) => {
      let body = '';
      
      res.on('data', (chunk) => {
        body += chunk;
      });
      
      res.on('end', () => {
        try {
          const jsonResponse = JSON.parse(body);
          resolve({
            status: res.statusCode,
            body: jsonResponse,
            headers: res.headers
          });
        } catch (e) {
          resolve({
            status: res.statusCode,
            body: { raw: body },
            headers: res.headers
          });
        }
      });
    });

    req.on('error', (err) => {
      reject(err);
    });

    req.write(postData);
    req.end();
  });
}

/**
 * Print test result
 */
function printResult(testName, passed, expected, actual) {
  const status = passed 
    ? `${colors.green}${colors.bold}‚úì PASS${colors.reset}` 
    : `${colors.red}${colors.bold}‚úó FAIL${colors.reset}`;
  
  console.log(`\n${status} ${testName}`);
  console.log(`  Expected: ${expected}`);
  console.log(`  Actual:   ${actual}`);
}

/**
 * Sleep function for delays
 */
function sleep(ms) {
  return new Promise(resolve => setTimeout(resolve, ms));
}

/**
 * Run all tests
 */
async function runTests() {
  console.log(`\n${colors.cyan}${colors.bold}‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê${colors.reset}`);
  console.log(`${colors.cyan}${colors.bold}  High Priority Security Fixes - Verification Tests${colors.reset}`);
  console.log(`${colors.cyan}${colors.bold}  Sections: 2.1, 2.4, 2.5${colors.reset}`);
  console.log(`${colors.cyan}${colors.bold}‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê${colors.reset}\n`);

  let passedTests = 0;
  let totalTests = 2;

  // Test 1: Input Sanitization
  console.log(`${colors.yellow}Test 1: Input Sanitization (Section 2.4)${colors.reset}`);
  console.log(`${colors.cyan}Testing HTML/Script tag stripping...${colors.reset}`);
  
  try {
    const timestamp = Date.now();
    const maliciousInput = {
      firstName: '<script>alert("XSS")</script>Malicious',
      lastName: '<b>Bold</b>User',
      email: `sanitize${timestamp}@example.com`,
      phone: '09171234567',
      password: 'StrongP@ss1!'
    };

    const response1 = await makeRequest('/api/auth/signup', maliciousInput);

    // Check if the response indicates successful sanitization
    // The server should either:
    // 1. Accept the request with sanitized values (201)
    // 2. Reject if email already exists (400)
    // But it should NOT contain the script tags in any form

    const responseString = JSON.stringify(response1.body);
    const containsScriptTag = responseString.includes('<script>') || 
                              responseString.includes('</script>') ||
                              responseString.includes('<b>') ||
                              responseString.includes('</b>');

    // PASS if: No script tags in response AND status is 201 (created) or 400 (any validation error)
    const passed1 = !containsScriptTag && (response1.status === 201 || response1.status === 400);
    
    if (passed1) passedTests++;
    
    printResult(
      'Input Sanitization (HTML/Script removal)',
      passed1,
      'No HTML tags in response, status 201 or 400',
      `${response1.status} - Script tags removed: ${!containsScriptTag}`
    );

    if (response1.status === 201 && response1.body.user) {
      console.log(`  ${colors.cyan}Sanitized firstName: "${response1.body.user.firstName}"${colors.reset}`);
      console.log(`  ${colors.cyan}Sanitized lastName: "${response1.body.user.lastName}"${colors.reset}`);
    }
  } catch (err) {
    printResult('Input Sanitization', false, '201 or 400', `Connection error: ${err.message}`);
  }

  // Small delay before rate limit test
  console.log(`\n${colors.cyan}Waiting 2 seconds before rate limit test...${colors.reset}`);
  await sleep(2000);

  // Test 2: Rate Limiting
  console.log(`\n${colors.yellow}Test 2: Authentication Rate Limiting (Section 2.5)${colors.reset}`);
  console.log(`${colors.cyan}Sending 10 login requests rapidly (limit is 5 per 15 min)...${colors.reset}`);
  
  try {
    const loginData = {
      email: 'ratetest@example.com',
      password: 'TestP@ss1!'
    };

    let rateLimitTriggered = false;
    let triggerAttempt = 0;
    let responses = [];

    // Send 10 rapid login requests
    for (let i = 1; i <= 10; i++) {
      const response = await makeRequest('/api/auth/login', loginData);
      responses.push({ attempt: i, status: response.status });
      
      console.log(`  Attempt ${i}: Status ${response.status}`);
      
      // Check if rate limit was triggered (429 status)
      if (response.status === 429 && !rateLimitTriggered) {
        rateLimitTriggered = true;
        triggerAttempt = i;
      }

      // Small delay to avoid overwhelming the server
      await sleep(50);
    }

    // Rate limit should trigger on 5th or 6th request (accounting for any previous activity)
    // PASS if: Rate limit triggered AND it happened at attempt 5 or 6
    const passed2 = rateLimitTriggered && (triggerAttempt === 5 || triggerAttempt === 6);
    
    if (passed2) passedTests++;
    
    printResult(
      'Rate Limiting (Auth endpoints)',
      passed2,
      '5th or 6th request returns 429 (Too Many Requests)',
      rateLimitTriggered 
        ? `Rate limit triggered at attempt ${triggerAttempt}` 
        : 'Rate limit NOT triggered'
    );

    // Show rate limit headers if present
    if (rateLimitTriggered) {
      const failedResponse = await makeRequest('/api/auth/login', loginData);
      if (failedResponse.headers['ratelimit-limit']) {
        console.log(`  ${colors.cyan}RateLimit-Limit: ${failedResponse.headers['ratelimit-limit']}${colors.reset}`);
        console.log(`  ${colors.cyan}RateLimit-Remaining: ${failedResponse.headers['ratelimit-remaining']}${colors.reset}`);
        console.log(`  ${colors.cyan}RateLimit-Reset: ${failedResponse.headers['ratelimit-reset']}${colors.reset}`);
      }
    }
  } catch (err) {
    printResult('Rate Limiting', false, '429 on 6th attempt', `Connection error: ${err.message}`);
  }

  // Summary
  console.log(`\n${colors.cyan}${colors.bold}‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê${colors.reset}`);
  console.log(`${colors.cyan}${colors.bold}  Test Summary${colors.reset}`);
  console.log(`${colors.cyan}${colors.bold}‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê${colors.reset}\n`);
  
  const allPassed = passedTests === totalTests;
  const summaryColor = allPassed ? colors.green : colors.red;
  
  console.log(`  ${summaryColor}${colors.bold}${passedTests}/${totalTests} tests passed${colors.reset}`);
  
  if (allPassed) {
    console.log(`\n  ${colors.green}${colors.bold}‚úì ALL HIGH PRIORITY FIXES VERIFIED!${colors.reset}`);
    console.log(`\n  ${colors.cyan}Note: Rate limits will reset after 15 minutes.${colors.reset}`);
    console.log(`  ${colors.cyan}To test again, wait 15 minutes or restart the server.${colors.reset}\n`);
    process.exit(0);
  } else {
    console.log(`\n  ${colors.red}${colors.bold}‚úó Some tests failed. Please review the implementation.${colors.reset}\n`);
    process.exit(1);
  }
}

// Check if server is running
console.log(`${colors.cyan}Checking if server is running on http://localhost:3000...${colors.reset}`);

const checkReq = http.request({
  hostname: 'localhost',
  port: 3000,
  path: '/api/rooms',
  method: 'GET'
}, (res) => {
  console.log(`${colors.green}‚úì Server is running${colors.reset}`);
  runTests().catch(err => {
    console.error(`\n${colors.red}Test execution error: ${err.message}${colors.reset}\n`);
    process.exit(1);
  });
});

checkReq.on('error', (err) => {
  console.error(`\n${colors.red}‚úó Cannot connect to server on http://localhost:3000${colors.reset}`);
  console.error(`  Error: ${err.message}`);
  console.error(`\n  ${colors.yellow}Please start the server first:${colors.reset}`);
  console.error(`  ${colors.yellow}cd server && node server.js${colors.reset}\n`);
  process.exit(1);
});

checkReq.end();
</file>

<file path="scripts/test-idor-fix.js">
/**
 * IDOR Vulnerability Test Script
 * Tests if guest_id manipulation is properly blocked
 * 
 * Run with: node server/scripts/test-idor-fix.js
 */

const http = require('http');

// ANSI color codes for terminal output
const colors = {
  reset: '\x1b[0m',
  red: '\x1b[31m',
  green: '\x1b[32m',
  yellow: '\x1b[33m',
  blue: '\x1b[34m',
  cyan: '\x1b[36m',
  bold: '\x1b[1m'
};

// Configuration
const API_BASE = 'http://localhost:3000/api';
const TEST_USER = {
  email: 'test@example.com',
  password: 'password123',
  firstName: 'Test',
  lastName: 'User',
  phone: '09171234567'
};

// Helper: Make HTTP request
function makeRequest(method, path, body = null, token = null) {
  return new Promise((resolve, reject) => {
    const url = new URL(API_BASE + path);
    const options = {
      hostname: url.hostname,
      port: url.port || 3000,
      path: url.pathname + url.search,
      method: method,
      headers: {
        'Content-Type': 'application/json'
      }
    };

    if (token) {
      options.headers['Authorization'] = `Bearer ${token}`;
    }

    const req = http.request(options, (res) => {
      let data = '';
      res.on('data', chunk => data += chunk);
      res.on('end', () => {
        try {
          resolve({
            status: res.statusCode,
            data: JSON.parse(data)
          });
        } catch (e) {
          resolve({
            status: res.statusCode,
            data: data
          });
        }
      });
    });

    req.on('error', reject);
    
    if (body) {
      req.write(JSON.stringify(body));
    }
    
    req.end();
  });
}

// Helper: Print colored output
function printResult(status, message) {
  const color = status === 'PASS' ? colors.green : colors.red;
  const symbol = status === 'PASS' ? '‚úì' : '‚úó';
  console.log(`${color}${colors.bold}${symbol} ${status}: ${message}${colors.reset}`);
}

function printInfo(message) {
  console.log(`${colors.cyan}‚Ñπ ${message}${colors.reset}`);
}

function printHeader(message) {
  console.log(`\n${colors.bold}${colors.blue}‚ïê‚ïê‚ïê ${message} ‚ïê‚ïê‚ïê${colors.reset}`);
}

// Main test function
async function runIDORTest() {
  console.log(`${colors.bold}${colors.yellow}
‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïó
‚ïë         IDOR VULNERABILITY TEST - GUEST_ID INJECTION       ‚ïë
‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù
${colors.reset}`);

  try {
    // Step 1: Create or login test user
    printHeader('Step 1: User Authentication');
    printInfo('Attempting to login as test user...');
    
    let loginResponse = await makeRequest('POST', '/auth/login', {
      email: TEST_USER.email,
      password: TEST_USER.password
    });

    // If login fails, try to create account
    if (!loginResponse.data.success) {
      printInfo('User not found. Creating test account...');
      
      const signupResponse = await makeRequest('POST', '/auth/signup', TEST_USER);
      
      if (!signupResponse.data.success) {
        printResult('FAIL', `Could not create test user: ${signupResponse.data.message}`);
        process.exit(1);
      }
      
      loginResponse = signupResponse;
    }

    const token = loginResponse.data.token;
    const realUserId = loginResponse.data.user.id;
    
    printResult('PASS', `Authenticated as User ID: ${realUserId}`);
    console.log(`   Token: ${token.substring(0, 20)}...`);

    // Step 2: Get available room for test booking
    printHeader('Step 2: Fetch Available Room');
    printInfo('Requesting room information...');
    
    const roomsResponse = await makeRequest('GET', '/rooms', null);
    
    if (!roomsResponse.data.success || !roomsResponse.data.rooms || roomsResponse.data.rooms.length === 0) {
      printResult('FAIL', 'No rooms available for testing');
      process.exit(1);
    }
    
    const testRoom = roomsResponse.data.rooms[0];
    printResult('PASS', `Using room: ${testRoom.name} (${testRoom.slug})`);

    // Step 3: Attempt IDOR Attack - Try to book as another user
    printHeader('Step 3: IDOR Attack Simulation');
    const FAKE_GUEST_ID = 9999;
    printInfo(`Attempting to create booking with guest_id: ${FAKE_GUEST_ID}`);
    printInfo(`Authenticated user's real ID: ${realUserId}`);
    
    const tomorrow = new Date();
    tomorrow.setDate(tomorrow.getDate() + 1);
    const checkInDate = tomorrow.toISOString().split('T')[0];
    
    const maliciousBookingRequest = {
      roomSlug: testRoom.slug,
      checkInDate: checkInDate,
      checkInTime: '14:00',
      duration: '3',
      totalAmount: testRoom.rates['3h'],
      guestInfo: {
        guestId: FAKE_GUEST_ID, // üö® MALICIOUS: Trying to book as another user
        firstName: TEST_USER.firstName,
        lastName: TEST_USER.lastName,
        email: TEST_USER.email,
        phone: TEST_USER.phone
      }
    };

    console.log(`${colors.yellow}   üì§ Sending malicious request with guest_id: ${FAKE_GUEST_ID}${colors.reset}`);
    
    const bookingResponse = await makeRequest(
      'POST',
      '/payment/create-checkout',
      maliciousBookingRequest,
      token
    );

    if (!bookingResponse.data.success) {
      printResult('FAIL', `Booking creation failed: ${bookingResponse.data.message}`);
      process.exit(1);
    }

    const referenceCode = bookingResponse.data.referenceCode;
    printInfo(`Booking created with reference: ${referenceCode}`);

    // Step 4: Verify which guest_id was actually saved
    printHeader('Step 4: Verify Database Entry');
    printInfo('Checking which guest_id was saved in the database...');
    
    // Wait a moment for DB write
    await new Promise(resolve => setTimeout(resolve, 500));
    
    const verifyResponse = await makeRequest('GET', `/payment/booking/${referenceCode}`, null);
    
    if (!verifyResponse.data.success) {
      printResult('FAIL', 'Could not verify booking in database');
      process.exit(1);
    }

    // We can't directly see guest_id from this endpoint, so check via my-bookings
    const myBookingsResponse = await makeRequest('GET', '/payment/my-bookings', null, token);
    
    if (!myBookingsResponse.data.success) {
      printResult('FAIL', 'Could not fetch user bookings');
      process.exit(1);
    }

    const createdBooking = myBookingsResponse.data.bookings.find(
      b => b.referenceCode === referenceCode
    );

    if (!createdBooking) {
      printResult('FAIL', 'Booking not found in user\'s bookings (possible IDOR success)');
      console.log(`${colors.red}   ‚ö†Ô∏è  This means the booking was created under guest_id ${FAKE_GUEST_ID}${colors.reset}`);
      console.log(`${colors.red}   ‚ö†Ô∏è  SECURITY VULNERABILITY DETECTED!${colors.reset}`);
      process.exit(1);
    }

    // Step 5: Final Verdict
    printHeader('Step 5: Test Results');
    
    console.log(`\n${colors.bold}Expected Behavior:${colors.reset}`);
    console.log(`   The booking should be created under the authenticated user's ID: ${colors.green}${realUserId}${colors.reset}`);
    console.log(`   NOT under the malicious guest_id: ${colors.red}${FAKE_GUEST_ID}${colors.reset}`);
    
    console.log(`\n${colors.bold}Actual Result:${colors.reset}`);
    console.log(`   Booking ${referenceCode} was found in user ${realUserId}'s bookings`);
    
    printResult('PASS', 'IDOR VULNERABILITY FIXED ‚úì');
    console.log(`${colors.green}   ‚úì The server correctly ignored the malicious guest_id${colors.reset}`);
    console.log(`${colors.green}   ‚úì Booking was created using the JWT-verified user ID${colors.reset}`);
    console.log(`${colors.green}   ‚úì Unauthorized booking on behalf of others is prevented${colors.reset}`);

    console.log(`\n${colors.bold}${colors.green}‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïó`);
    console.log(`‚ïë                    SECURITY TEST PASSED                    ‚ïë`);
    console.log(`‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù${colors.reset}\n`);

  } catch (error) {
    printResult('FAIL', `Test execution error: ${error.message}`);
    console.error(error);
    process.exit(1);
  }
}

// Run the test
runIDORTest();
</file>

<file path="scripts/test-low-priority.js">
// server/scripts/test-low-priority.js
const http = require('http');
const fs = require('fs');
const path = require('path');

const BASE_URL = 'http://localhost:3000/api';
const COLORS = {
    GREEN: '\x1b[32m',
    RED: '\x1b[31m',
    RESET: '\x1b[0m',
    YELLOW: '\x1b[33m'
};

async function log(msg, color = COLORS.RESET) {
    console.log(`${color}${msg}${COLORS.RESET}`);
}

async function testBodyLimit() {
    await log('\n=== TEST 1: Request Body Size Limit (10KB) ===', COLORS.YELLOW);
    
    // 1. Create a 15KB payload
    const largePayload = { data: 'x'.repeat(15 * 1024) };
    
    try {
        const res = await fetch(`${BASE_URL}/auth/login`, {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify(largePayload)
        });

        if (res.status === 413) {
            await log('‚úÖ PASS: Server blocked 15KB payload (Status 413)', COLORS.GREEN);
        } else {
            await log(`‚ùå FAIL: Server accepted large payload (Status ${res.status})`, COLORS.RED);
        }
    } catch (err) {
        await log(`‚ùå ERROR: Could not connect to server: ${err.message}`, COLORS.RED);
    }
}

async function testCORS() {
    await log('\n=== TEST 2: CORS Configuration ===', COLORS.YELLOW);

    // Case A: Allowed Origin (localhost:5173)
    try {
        const resAllowed = await fetch(`${BASE_URL}/rooms`, {
            method: 'GET',
            headers: { 'Origin': 'http://localhost:5173' }
        });
        
        const allowHeader = resAllowed.headers.get('Access-Control-Allow-Origin');
        if (allowHeader === 'http://localhost:5173') {
            await log('‚úÖ PASS: Allowed Origin (localhost:5173) accepted', COLORS.GREEN);
        } else {
            await log(`‚ùå FAIL: Allowed Origin header missing or wrong. Got: ${allowHeader}`, COLORS.RED);
        }
    } catch (err) {
        await log(`‚ùå ERROR: ${err.message}`, COLORS.RED);
    }

    // Case B: Blocked Origin (malicious.com)
    try {
        const resBlocked = await fetch(`${BASE_URL}/rooms`, {
            method: 'GET',
            headers: { 'Origin': 'http://malicious-site.com' }
        });

        // Note: When CORS blocks, the browser throws an error, but fetch in Node might just return 
        // the response WITHOUT the Allow-Origin header, or a 500 error depending on your middleware setup.
        const allowHeaderBlocked = resBlocked.headers.get('Access-Control-Allow-Origin');
        
        if (!allowHeaderBlocked || resBlocked.status === 500) {
            await log('‚úÖ PASS: Malicious Origin blocked (No Allow Header or 500)', COLORS.GREEN);
        } else {
            await log(`‚ùå FAIL: Malicious Origin was ALLOWED! Header: ${allowHeaderBlocked}`, COLORS.RED);
        }
    } catch (err) {
        // If fetch throws because of CORS (in some environments), that's also a pass
        await log('‚úÖ PASS: Malicious Origin blocked (Network Error)', COLORS.GREEN);
    }
}

async function checkDynamicURL() {
    await log('\n=== TEST 3: Dynamic URL (Static Code Check) ===', COLORS.YELLOW);
    
    const controllerPath = path.join(__dirname, '../controllers/paymentController.js');
    
    try {
        const content = fs.readFileSync(controllerPath, 'utf8');
        
        if (content.includes('process.env.FRONTEND_URL') && content.includes('http://localhost:5173')) {
            await log('‚úÖ PASS: Code uses process.env.FRONTEND_URL with localhost fallback', COLORS.GREEN);
        } else if (content.includes('process.env.FRONTEND_URL')) {
            await log('‚úÖ PASS: Code uses process.env.FRONTEND_URL', COLORS.GREEN);
        } else {
            await log('‚ùå FAIL: "process.env.FRONTEND_URL" not found in paymentController.js', COLORS.RED);
        }
    } catch (err) {
        await log(`‚ùå ERROR: Could not read paymentController.js: ${err.message}`, COLORS.RED);
    }
}

async function run() {
    console.log('üß™ STARTING LOW PRIORITY CONFIG TESTS...');
    await testBodyLimit();
    await testCORS();
    await checkDynamicURL();
    console.log('\nüèÅ TESTS COMPLETE');
}

run();
</file>

<file path="scripts/test-medium-priority.js">
/**
 * Medium Priority Fixes - Verification Test Script
 * Balai Almeda Hotel System
 * 
 * Tests Sections 2.2, 2.6, 2.7:
 * - Environment Validation
 * - Strong Password Policy
 * - Email Validation
 * 
 * Run: node server/scripts/test-medium-priority.js
 * (Ensure server is running on http://localhost:3000)
 */

const http = require('http');

// ANSI color codes for terminal output
const colors = {
  reset: '\x1b[0m',
  green: '\x1b[32m',
  red: '\x1b[31m',
  yellow: '\x1b[33m',
  cyan: '\x1b[36m',
  bold: '\x1b[1m'
};

/**
 * Make HTTP POST request to signup endpoint
 */
function makeSignupRequest(data) {
  return new Promise((resolve, reject) => {
    const postData = JSON.stringify(data);
    
    const options = {
      hostname: 'localhost',
      port: 3000,
      path: '/api/auth/signup',
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
        'Content-Length': Buffer.byteLength(postData)
      }
    };

    const req = http.request(options, (res) => {
      let body = '';
      
      res.on('data', (chunk) => {
        body += chunk;
      });
      
      res.on('end', () => {
        try {
          const jsonResponse = JSON.parse(body);
          resolve({
            status: res.statusCode,
            body: jsonResponse
          });
        } catch (e) {
          resolve({
            status: res.statusCode,
            body: { raw: body }
          });
        }
      });
    });

    req.on('error', (err) => {
      reject(err);
    });

    req.write(postData);
    req.end();
  });
}

/**
 * Print test result
 */
function printResult(testName, passed, expected, actual) {
  const status = passed 
    ? `${colors.green}${colors.bold}‚úì PASS${colors.reset}` 
    : `${colors.red}${colors.bold}‚úó FAIL${colors.reset}`;
  
  console.log(`\n${status} ${testName}`);
  console.log(`  Expected: ${expected}`);
  console.log(`  Actual:   ${actual}`);
}

/**
 * Run all tests
 */
async function runTests() {
  console.log(`\n${colors.cyan}${colors.bold}‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê${colors.reset}`);
  console.log(`${colors.cyan}${colors.bold}  Medium Priority Fixes - Verification Tests${colors.reset}`);
  console.log(`${colors.cyan}${colors.bold}  Sections: 2.2, 2.6, 2.7${colors.reset}`);
  console.log(`${colors.cyan}${colors.bold}‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê${colors.reset}\n`);

  let passedTests = 0;
  let totalTests = 3;

  // Test 1: Weak Password
  console.log(`${colors.yellow}Test 1: Weak Password Rejection (Section 2.6)${colors.reset}`);
  try {
    const response1 = await makeSignupRequest({
      firstName: 'Test',
      lastName: 'User',
      email: 'test1@example.com',
      phone: '09171234567',
      password: 'weakpass' // No number, no special char
    });

    const passed1 = response1.status === 400 && 
                    response1.body.message && 
                    response1.body.message.includes('8+ chars with a number and special character');
    
    if (passed1) passedTests++;
    
    printResult(
      'Weak Password (weakpass)',
      passed1,
      '400 - Password must be 8+ chars with a number and special character',
      `${response1.status} - ${response1.body.message || 'Unknown error'}`
    );
  } catch (err) {
    printResult('Weak Password', false, '400 error', `Connection error: ${err.message}`);
  }

  // Test 2: Invalid Email
  console.log(`\n${colors.yellow}Test 2: Invalid Email Rejection (Section 2.7)${colors.reset}`);
  try {
    const response2 = await makeSignupRequest({
      firstName: 'Test',
      lastName: 'User',
      email: 'bad-email', // Invalid format
      phone: '09171234567',
      password: 'StrongP@ss1!'
    });

    const passed2 = response2.status === 400 && 
                    response2.body.message && 
                    response2.body.message.includes('Invalid email format');
    
    if (passed2) passedTests++;
    
    printResult(
      'Invalid Email (bad-email)',
      passed2,
      '400 - Invalid email format',
      `${response2.status} - ${response2.body.message || 'Unknown error'}`
    );
  } catch (err) {
    printResult('Invalid Email', false, '400 error', `Connection error: ${err.message}`);
  }

  // Test 3: Valid Request
  console.log(`\n${colors.yellow}Test 3: Valid Request (All Validations Pass)${colors.reset}`);
  try {
    const timestamp = Date.now();
    const response3 = await makeSignupRequest({
      firstName: 'Valid',
      lastName: 'User',
      email: `validuser${timestamp}@example.com`, // Unique email
      phone: '09171234567',
      password: 'StrongP@ss1!' // Strong password
    });

    // Accept both 201 (created) and 400 (email exists) as valid
    const passed3 = response3.status === 201 || 
                    (response3.status === 400 && response3.body.message && 
                     response3.body.message.includes('Email already registered'));
    
    if (passed3) passedTests++;
    
    printResult(
      'Valid Request (StrongP@ss1! + good@email.com)',
      passed3,
      '201 Created OR 400 Email exists',
      `${response3.status} - ${response3.body.message || 'User created successfully'}`
    );
  } catch (err) {
    printResult('Valid Request', false, '201 or 400', `Connection error: ${err.message}`);
  }

  // Summary
  console.log(`\n${colors.cyan}${colors.bold}‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê${colors.reset}`);
  console.log(`${colors.cyan}${colors.bold}  Test Summary${colors.reset}`);
  console.log(`${colors.cyan}${colors.bold}‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê${colors.reset}\n`);
  
  const allPassed = passedTests === totalTests;
  const summaryColor = allPassed ? colors.green : colors.red;
  
  console.log(`  ${summaryColor}${colors.bold}${passedTests}/${totalTests} tests passed${colors.reset}`);
  
  if (allPassed) {
    console.log(`\n  ${colors.green}${colors.bold}‚úì ALL MEDIUM PRIORITY FIXES VERIFIED!${colors.reset}\n`);
    process.exit(0);
  } else {
    console.log(`\n  ${colors.red}${colors.bold}‚úó Some tests failed. Please review the implementation.${colors.reset}\n`);
    process.exit(1);
  }
}

// Check if server is running
console.log(`${colors.cyan}Checking if server is running on http://localhost:3000...${colors.reset}`);

const checkReq = http.request({
  hostname: 'localhost',
  port: 3000,
  path: '/api/rooms',
  method: 'GET'
}, (res) => {
  console.log(`${colors.green}‚úì Server is running${colors.reset}`);
  runTests().catch(err => {
    console.error(`\n${colors.red}Test execution error: ${err.message}${colors.reset}\n`);
    process.exit(1);
  });
});

checkReq.on('error', (err) => {
  console.error(`\n${colors.red}‚úó Cannot connect to server on http://localhost:3000${colors.reset}`);
  console.error(`  Error: ${err.message}`);
  console.error(`\n  ${colors.yellow}Please start the server first:${colors.reset}`);
  console.error(`  ${colors.yellow}cd server && node server.js${colors.reset}\n`);
  process.exit(1);
});

checkReq.end();
</file>

<file path="scripts/test-price-fix.js">
/**
 * PRICE MANIPULATION FIX - TEST SCRIPT
 * =====================================
 * 
 * WHAT THIS TESTS:
 * - Verifies that users cannot manipulate booking prices by sending fake totalAmount
 * - Confirms server ALWAYS calculates price from database room rates
 * - Ensures both PayMongo and database use server-calculated prices
 * 
 * VULNERABILITY (BEFORE FIX):
 * - Client could send totalAmount: 1.00 and book a ‚Ç±1500 room for ‚Ç±1
 * - Payment gateway would charge ‚Ç±1, database would store ‚Ç±1
 * - Result: Massive revenue loss
 * 
 * FIX:
 * - Server ignores ANY totalAmount from client
 * - Fetches room from database
 * - Calculates price based on room's base_rate_XXh field
 * - Uses ONLY server-calculated price for both PayMongo and DB
 * - Logs manipulation attempts for security audit
 * 
 * HOW TO RUN:
 *   node server/scripts/test-price-fix.js
 * 
 * EXPECTED RESULT:
 *   ‚úÖ All tests PASS (green)
 *   ‚õî Any FAIL (red) = vulnerability still exists
 */

const http = require('http');
const https = require('https');

// ANSI Color Codes
const GREEN = '\x1b[32m';
const RED = '\x1b[31m';
const YELLOW = '\x1b[33m';
const BLUE = '\x1b[36m';
const RESET = '\x1b[0m';
const BOLD = '\x1b[1m';

// Test Configuration
const API_BASE = process.env.API_URL || 'http://localhost:3000';
const TEST_USER = {
  email: 'test_price@example.com',
  password: 'TestPassword123!',
  firstName: 'Price',
  lastName: 'Tester',
  phone: '09123456789',
  address: 'Test Address'
};

let authToken = null;
let testUserId = null;

// Helper: HTTP Request
function makeRequest(method, path, data = null, token = null) {
  return new Promise((resolve, reject) => {
    const url = new URL(path, API_BASE);
    const isHttps = url.protocol === 'https:';
    const lib = isHttps ? https : http;

    const options = {
      hostname: url.hostname,
      port: url.port || (isHttps ? 443 : 80),
      path: url.pathname + url.search,
      method: method,
      headers: {
        'Content-Type': 'application/json'
      }
    };

    if (token) {
      options.headers['Authorization'] = `Bearer ${token}`;
    }

    const req = lib.request(options, (res) => {
      let body = '';
      res.on('data', chunk => body += chunk);
      res.on('end', () => {
        try {
          const parsed = JSON.parse(body);
          resolve({ status: res.statusCode, data: parsed });
        } catch (e) {
          resolve({ status: res.statusCode, data: body });
        }
      });
    });

    req.on('error', reject);
    if (data) req.write(JSON.stringify(data));
    req.end();
  });
}

// Helper: Print Result
function printResult(testName, passed, details = '') {
  const icon = passed ? '‚úÖ' : '‚õî';
  const color = passed ? GREEN : RED;
  console.log(`${color}${icon} ${testName}${RESET}`);
  if (details) {
    console.log(`   ${details}`);
  }
}

// Step 1: Register Test User
async function registerTestUser() {
  console.log(`\n${BLUE}${BOLD}=== STEP 1: Register Test User ===${RESET}`);
  
  try {
    const res = await makeRequest('POST', '/api/auth/signup', TEST_USER);
    
    if (res.status === 201 || res.status === 200) {
      authToken = res.data.token;
      testUserId = res.data.userId || res.data.user?.id;
      printResult('Test user registered', true, `User ID: ${testUserId}`);
      return true;
    } else if (res.status === 400 && res.data.message?.includes('already')) {
      // User already exists, try to login
      console.log(`${YELLOW}‚Ñπ User exists, logging in...${RESET}`);
      return await loginTestUser();
    } else {
      printResult('Test user registration', false, `Status: ${res.status}, ${JSON.stringify(res.data)}`);
      return false;
    }
  } catch (error) {
    printResult('Test user registration', false, error.message);
    return false;
  }
}

// Step 1b: Login Test User
async function loginTestUser() {
  try {
    const res = await makeRequest('POST', '/api/auth/login', {
      email: TEST_USER.email,
      password: TEST_USER.password
    });
    
    if (res.status === 200) {
      authToken = res.data.token;
      testUserId = res.data.userId || res.data.user?.id;
      printResult('Test user login', true, `User ID: ${testUserId}`);
      return true;
    } else {
      printResult('Test user login', false, `Status: ${res.status}`);
      return false;
    }
  } catch (error) {
    printResult('Test user login', false, error.message);
    return false;
  }
}

// Step 2: Test Price Manipulation Attack
async function testPriceManipulation() {
  console.log(`\n${BLUE}${BOLD}=== STEP 2: Test Price Manipulation Attack ===${RESET}`);
  
  // Prepare a booking request with MANIPULATED price
  const checkInDate = new Date();
  checkInDate.setDate(checkInDate.getDate() + 2);
  const dateStr = checkInDate.toISOString().split('T')[0];
  
  const maliciousBooking = {
    roomSlug: 'deluxe-room',
    checkInDate: dateStr,
    checkInTime: '14:00',
    duration: '12',
    totalAmount: 1.00, // üö® ATTACK: Trying to book a ‚Ç±1500+ room for ‚Ç±1
    guestInfo: {
      firstName: TEST_USER.firstName,
      lastName: TEST_USER.lastName,
      email: TEST_USER.email,
      phone: TEST_USER.phone,
      guestId: testUserId
    }
  };

  console.log(`${YELLOW}‚ö†Ô∏è  Attempting price manipulation:${RESET}`);
  console.log(`   Sending totalAmount: ‚Ç±${maliciousBooking.totalAmount} (fake)`);
  console.log(`   Expected real price: ~‚Ç±1500+ (12h Deluxe room)`);

  try {
    const res = await makeRequest('POST', '/api/payment/create-checkout', maliciousBooking, authToken);
    
    if (res.status === 200 && res.data.success) {
      // Checkout was created - now verify the ACTUAL price used
      const referenceCode = res.data.referenceCode;
      console.log(`   Checkout created: ${referenceCode}`);
      
      // Wait a bit for DB write
      await new Promise(r => setTimeout(r, 1000));
      
      // Fetch the booking from database to check stored price
      const bookingRes = await makeRequest('GET', `/api/payment/booking/${referenceCode}`, null, authToken);
      
      if (bookingRes.status === 200) {
        const actualPrice = parseFloat(bookingRes.data.booking.totalAmount);
        console.log(`   Server-calculated price: ‚Ç±${actualPrice}`);
        
        // PASS if actual price is NOT the manipulated ‚Ç±1, but the real room rate (‚Ç±1500+)
        const wasManipulated = (actualPrice === 1.00);
        const isRealisticPrice = (actualPrice >= 1000); // Deluxe 12h should be ~‚Ç±1500+
        
        if (!wasManipulated && isRealisticPrice) {
          printResult(
            'Price manipulation BLOCKED',
            true,
            `Server enforced ‚Ç±${actualPrice} (ignored client's ‚Ç±1.00)`
          );
          return true;
        } else {
          printResult(
            'Price manipulation BLOCKED',
            false,
            `Server used ‚Ç±${actualPrice} - SHOULD be ~‚Ç±1500, NOT ‚Ç±1`
          );
          return false;
        }
      } else {
        printResult('Fetch booking for verification', false, `Status: ${bookingRes.status}`);
        return false;
      }
    } else {
      printResult('Create checkout with fake price', false, `Status: ${res.status}, ${JSON.stringify(res.data)}`);
      return false;
    }
  } catch (error) {
    printResult('Price manipulation test', false, error.message);
    return false;
  }
}

// Step 3: Test Zero Price Attack
async function testZeroPriceAttack() {
  console.log(`\n${BLUE}${BOLD}=== STEP 3: Test Zero Price Attack ===${RESET}`);
  
  const checkInDate = new Date();
  checkInDate.setDate(checkInDate.getDate() + 3);
  const dateStr = checkInDate.toISOString().split('T')[0];
  
  const zeroPriceBooking = {
    roomSlug: 'standard-room',
    checkInDate: dateStr,
    checkInTime: '10:00',
    duration: '6',
    totalAmount: 0, // üö® ATTACK: Trying to book for free
    guestInfo: {
      firstName: TEST_USER.firstName,
      lastName: TEST_USER.lastName,
      email: TEST_USER.email,
      phone: TEST_USER.phone,
      guestId: testUserId
    }
  };

  console.log(`${YELLOW}‚ö†Ô∏è  Attempting zero-price attack:${RESET}`);
  console.log(`   Sending totalAmount: ‚Ç±${zeroPriceBooking.totalAmount} (free)`);

  try {
    const res = await makeRequest('POST', '/api/payment/create-checkout', zeroPriceBooking, authToken);
    
    if (res.status === 200 && res.data.success) {
      const referenceCode = res.data.referenceCode;
      await new Promise(r => setTimeout(r, 1000));
      
      const bookingRes = await makeRequest('GET', `/api/payment/booking/${referenceCode}`, null, authToken);
      
      if (bookingRes.status === 200) {
        const actualPrice = parseFloat(bookingRes.data.booking.totalAmount);
        
        const isZero = (actualPrice === 0);
        const isPositive = (actualPrice > 0);
        
        if (!isZero && isPositive) {
          printResult(
            'Zero-price attack BLOCKED',
            true,
            `Server enforced ‚Ç±${actualPrice} (ignored client's ‚Ç±0)`
          );
          return true;
        } else {
          printResult(
            'Zero-price attack BLOCKED',
            false,
            `Server allowed ‚Ç±${actualPrice} - should be > 0`
          );
          return false;
        }
      } else {
        printResult('Verify zero-price booking', false, `Status: ${bookingRes.status}`);
        return false;
      }
    } else {
      printResult('Create checkout with zero price', false, `Status: ${res.status}`);
      return false;
    }
  } catch (error) {
    printResult('Zero-price attack test', false, error.message);
    return false;
  }
}

// Step 4: Test Negative Price Attack
async function testNegativePriceAttack() {
  console.log(`\n${BLUE}${BOLD}=== STEP 4: Test Negative Price Attack ===${RESET}`);
  
  const checkInDate = new Date();
  checkInDate.setDate(checkInDate.getDate() + 4);
  const dateStr = checkInDate.toISOString().split('T')[0];
  
  const negativeBooking = {
    roomSlug: 'value-room',
    checkInDate: dateStr,
    checkInTime: '16:00',
    duration: '3',
    totalAmount: -500, // üö® ATTACK: Negative price
    guestInfo: {
      firstName: TEST_USER.firstName,
      lastName: TEST_USER.lastName,
      email: TEST_USER.email,
      phone: TEST_USER.phone,
      guestId: testUserId
    }
  };

  console.log(`${YELLOW}‚ö†Ô∏è  Attempting negative price attack:${RESET}`);
  console.log(`   Sending totalAmount: ‚Ç±${negativeBooking.totalAmount} (negative)`);

  try {
    const res = await makeRequest('POST', '/api/payment/create-checkout', negativeBooking, authToken);
    
    if (res.status === 200 && res.data.success) {
      const referenceCode = res.data.referenceCode;
      await new Promise(r => setTimeout(r, 1000));
      
      const bookingRes = await makeRequest('GET', `/api/payment/booking/${referenceCode}`, null, authToken);
      
      if (bookingRes.status === 200) {
        const actualPrice = parseFloat(bookingRes.data.booking.totalAmount);
        
        const isNegative = (actualPrice < 0);
        const isPositive = (actualPrice > 0);
        
        if (!isNegative && isPositive) {
          printResult(
            'Negative price attack BLOCKED',
            true,
            `Server enforced ‚Ç±${actualPrice} (ignored client's ‚Ç±-500)`
          );
          return true;
        } else {
          printResult(
            'Negative price attack BLOCKED',
            false,
            `Server used ‚Ç±${actualPrice} - should be positive, not negative`
          );
          return false;
        }
      } else {
        printResult('Verify negative price booking', false, `Status: ${bookingRes.status}`);
        return false;
      }
    } else {
      printResult('Create checkout with negative price', false, `Status: ${res.status}`);
      return false;
    }
  } catch (error) {
    printResult('Negative price attack test', false, error.message);
    return false;
  }
}

// Main Test Runner
async function runTests() {
  console.log(`${BOLD}${BLUE}`);
  console.log('‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïó');
  console.log('‚ïë         PRICE MANIPULATION FIX - SECURITY TEST             ‚ïë');
  console.log('‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù');
  console.log(RESET);
  
  console.log(`${YELLOW}Testing against: ${API_BASE}${RESET}\n`);

  const results = [];

  // Step 1: Setup
  const setupSuccess = await registerTestUser();
  if (!setupSuccess) {
    console.log(`\n${RED}${BOLD}‚ùå SETUP FAILED - Cannot continue tests${RESET}`);
    process.exit(1);
  }

  // Step 2-4: Run attack tests
  results.push(await testPriceManipulation());
  results.push(await testZeroPriceAttack());
  results.push(await testNegativePriceAttack());

  // Final Report
  console.log(`\n${BOLD}${BLUE}‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïó`);
  console.log('‚ïë                      FINAL RESULTS                         ‚ïë');
  console.log(`‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù${RESET}\n`);

  const passed = results.filter(r => r === true).length;
  const failed = results.filter(r => r === false).length;
  const total = results.length;

  console.log(`${BOLD}Tests Passed: ${GREEN}${passed}/${total}${RESET}`);
  console.log(`${BOLD}Tests Failed: ${RED}${failed}/${total}${RESET}\n`);

  if (failed === 0) {
    console.log(`${GREEN}${BOLD}‚úÖ‚úÖ‚úÖ ALL TESTS PASSED ‚úÖ‚úÖ‚úÖ${RESET}`);
    console.log(`${GREEN}Price manipulation vulnerability is FIXED!${RESET}\n`);
    process.exit(0);
  } else {
    console.log(`${RED}${BOLD}‚õî‚õî‚õî TESTS FAILED ‚õî‚õî‚õî${RESET}`);
    console.log(`${RED}Price manipulation vulnerability still exists!${RESET}\n`);
    process.exit(1);
  }
}

// Run the tests
runTests().catch(error => {
  console.error(`${RED}${BOLD}Fatal error:${RESET}`, error);
  process.exit(1);
});
</file>

<file path="scripts/TRANSACTION-QUICK-REF.txt">
# Database Transaction - Quick Reference

## ‚úÖ FIXED: Transaction Safety in Payment Flow

---

## What Changed?

**File**: `server/controllers/paymentController.js`  
**Function**: `createCheckoutSession`

### Before (‚ùå No Transaction)
```javascript
// Create PayMongo session
const response = await axios.post(...);

// Create booking (separate operation)
await Booking.create({ ... });
```
**Problem**: If PayMongo succeeds but booking fails (or vice versa), data becomes inconsistent.

---

### After (‚úÖ With Transaction)
```javascript
const result = await sequelize.transaction(async (t) => {
  // All operations use same transaction
  const booking = await Booking.create({ ... }, { transaction: t });
  
  const response = await axios.post(...); // If fails, rollback
  
  await booking.update({ ... }, { transaction: t });
  
  return checkoutSession;
});
```
**Benefit**: All operations succeed together or fail together (atomicity).

---

## Key Points

### 1. Import Required
```javascript
const sequelize = require('../config/database');
```

### 2. Transaction Wrapper
```javascript
await sequelize.transaction(async (t) => {
  // All DB operations here must pass { transaction: t }
});
```

### 3. Automatic Rollback
- If ANY error is thrown inside the transaction block, ALL changes are rolled back
- No need to manually call `rollback()`

### 4. External API Calls
- Can be inside transaction
- If they fail and throw, transaction rolls back
- Database remains clean

---

## When to Use Transactions

‚úÖ **Use when**:
- Creating/updating multiple related records
- Combining database ops with external API calls
- Ensuring data consistency across operations

‚ùå **Not needed when**:
- Single database query (already atomic)
- Read-only operations
- Batch updates with single UPDATE query

---

## Error Handling

```javascript
try {
  const result = await sequelize.transaction(async (t) => {
    // Operations that might fail
  });
  
  res.json({ success: true });
  
} catch (error) {
  // Transaction already rolled back at this point
  console.error('Transaction failed:', error);
  res.status(500).json({ success: false });
}
```

---

## Testing the Fix

### Test Case 1: PayMongo Timeout
1. Temporarily set PayMongo API to invalid URL
2. Try to create booking
3. ‚úÖ Expected: No booking record in database, user sees error

### Test Case 2: Normal Flow
1. Create booking with valid data
2. ‚úÖ Expected: Booking created, PayMongo session created, checkout URL returned

### Test Case 3: Database Constraint Violation
1. Try to create booking with invalid guest_id
2. ‚úÖ Expected: Transaction rolls back, no orphaned PayMongo session

---

## SQL Queries Generated

### Before Transaction Fix
```sql
-- Separate, independent queries
INSERT INTO bookings (...) VALUES (...);
-- If this fails, no way to undo the previous insert
```

### After Transaction Fix
```sql
START TRANSACTION;
INSERT INTO bookings (...) VALUES (...);
-- If error occurs, automatic ROLLBACK
UPDATE bookings SET checkout_session_id = '...' WHERE booking_id = ...;
COMMIT;
```

---

## Performance

- **Overhead**: ~1-5ms per transaction
- **Benefit**: Prevents data corruption, reduces support tickets
- **Concurrency**: Sequelize manages connection pool efficiently

---

## Related Security Fixes (Untouched)

‚úÖ **IDOR Protection**: Uses JWT-verified guest_id  
‚úÖ **Price Manipulation**: Server-calculated pricing enforced  
‚úÖ **Duration Validation**: Only [3, 6, 12, 24] hours allowed  
‚úÖ **Time Validation**: 5-minute increments only  

---

## Debugging Tips

### Enable Transaction Logging
```javascript
// In config/database.js
const sequelize = new Sequelize({
  logging: console.log, // Shows SQL queries
  // ...
});
```

### Check for Orphaned Records
```sql
-- Find bookings without PayMongo sessions
SELECT * FROM bookings 
WHERE status = 'Pending_Payment' 
AND checkout_session_id IS NULL;
```

### Monitor Transaction Duration
```javascript
console.time('transaction');
await sequelize.transaction(async (t) => {
  // operations
});
console.timeEnd('transaction');
```

---

## Summary

‚úÖ **What was fixed**: Booking creation + PayMongo session creation now atomic  
‚úÖ **How it works**: Sequelize transaction with automatic rollback  
‚úÖ **Impact**: No orphaned bookings, consistent data  
‚úÖ **Security**: All previous fixes preserved  

**Risk 2.17 (No Database Transactions) ‚Üí RESOLVED**
</file>

<file path="scripts/verify_child_policy.sql">
-- ============================================================================
-- CHILD POLICY IMPLEMENTATION - QUICK VERIFICATION QUERIES
-- Run these queries to verify the implementation is working correctly
-- ============================================================================

-- -----------------------------------------------------------------------------
-- 1. SCHEMA VERIFICATION
-- Verify the child_ages column exists with correct data type
-- -----------------------------------------------------------------------------
DESCRIBE bookings;
-- Look for: child_ages | longtext | YES | | NULL | 

-- Alternative schema check
SHOW COLUMNS FROM bookings WHERE Field = 'child_ages';

-- -----------------------------------------------------------------------------
-- 2. SAMPLE DATA CHECK
-- View existing bookings with children (if any)
-- -----------------------------------------------------------------------------
SELECT 
    booking_id,
    reference_code,
    adults_count,
    children_count,
    child_ages,
    total_amount,
    status,
    DATE_FORMAT(created_at, '%Y-%m-%d %H:%i') as booking_date
FROM bookings
WHERE children_count > 0
ORDER BY created_at DESC
LIMIT 10;

-- -----------------------------------------------------------------------------
-- 3. JSON VALIDATION TEST
-- Test JSON parsing and extraction of child ages
-- -----------------------------------------------------------------------------
SELECT 
    reference_code,
    children_count,
    child_ages,
    JSON_VALID(child_ages) as is_valid_json,
    JSON_LENGTH(child_ages) as number_of_ages,
    JSON_EXTRACT(child_ages, '$[0]') as first_child_age,
    JSON_EXTRACT(child_ages, '$[1]') as second_child_age
FROM bookings
WHERE child_ages IS NOT NULL
ORDER BY created_at DESC
LIMIT 5;

-- -----------------------------------------------------------------------------
-- 4. PRICING VERIFICATION
-- Verify that total_amount includes child surcharges correctly
-- Calculate expected surcharge and compare with actual
-- -----------------------------------------------------------------------------
SELECT 
    b.reference_code,
    r.name as room_name,
    b.duration_hours,
    CASE b.duration_hours
        WHEN 3 THEN r.base_rate_3hr
        WHEN 6 THEN r.base_rate_6hr
        WHEN 12 THEN r.base_rate_12hr
        WHEN 24 THEN r.base_rate_24hr
    END as base_rate,
    b.children_count,
    b.child_ages,
    -- Actual total from database
    b.total_amount,
    -- Calculate expected surcharge (‚Ç±150 per child aged 7-13)
    -- This requires manual verification for now
    (b.total_amount - CASE b.duration_hours
        WHEN 3 THEN r.base_rate_3hr
        WHEN 6 THEN r.base_rate_6hr
        WHEN 12 THEN r.base_rate_12hr
        WHEN 24 THEN r.base_rate_24hr
    END) as calculated_surcharge
FROM bookings b
JOIN rooms r ON b.room_id = r.room_id
WHERE b.children_count > 0
ORDER BY b.created_at DESC
LIMIT 10;

-- -----------------------------------------------------------------------------
-- 5. CHILD AGE DISTRIBUTION ANALYSIS
-- Understand age distribution in bookings (useful for reporting)
-- -----------------------------------------------------------------------------
-- This query extracts all child ages from JSON arrays
-- Note: Requires MySQL 8.0+ for JSON_TABLE function
SELECT 
    child_age,
    COUNT(*) as frequency,
    CASE 
        WHEN child_age BETWEEN 0 AND 6 THEN 'Free (0-6 years)'
        WHEN child_age BETWEEN 7 AND 13 THEN 'Chargeable (7-13 years)'
        ELSE 'Invalid Age'
    END as age_category
FROM (
    SELECT JSON_UNQUOTE(JSON_EXTRACT(child_ages, CONCAT('$[', idx, ']'))) as child_age
    FROM bookings
    CROSS JOIN (
        SELECT 0 as idx UNION ALL SELECT 1
    ) as indexes
    WHERE child_ages IS NOT NULL
      AND JSON_EXTRACT(child_ages, CONCAT('$[', idx, ']')) IS NOT NULL
) as ages
GROUP BY child_age, age_category
ORDER BY child_age;

-- -----------------------------------------------------------------------------
-- 6. QUICK TEST: Insert Sample Booking with Children
-- Use this to test if child_ages column accepts data correctly
-- Run only if you want to create a test record
-- -----------------------------------------------------------------------------
-- UNCOMMENT TO RUN TEST INSERT:
/*
INSERT INTO bookings (
    guest_id,
    room_id,
    reference_code,
    check_in_time,
    check_out_time,
    duration_hours,
    adults_count,
    children_count,
    child_ages,
    source,
    status,
    total_amount
) VALUES (
    1,                                  -- guest_id (use a valid guest ID)
    1,                                  -- room_id (use a valid room ID)
    'TEST-CHILD-001',                   -- reference_code
    '2024-06-01 14:00:00',             -- check_in_time
    '2024-06-01 17:00:00',             -- check_out_time
    3,                                  -- duration_hours
    2,                                  -- adults_count
    2,                                  -- children_count
    '[6, 10]',                         -- child_ages (JSON array)
    'Web',                              -- source
    'Confirmed',                        -- status
    650.00                              -- total_amount (‚Ç±500 base + ‚Ç±150 for 10-yr-old)
);

-- Verify the test insert
SELECT * FROM bookings WHERE reference_code = 'TEST-CHILD-001';

-- Clean up test data (run after verification)
-- DELETE FROM bookings WHERE reference_code = 'TEST-CHILD-001';
*/

-- -----------------------------------------------------------------------------
-- 7. AUDIT REPORT: All Bookings with Children
-- Comprehensive report for management review
-- -----------------------------------------------------------------------------
SELECT 
    DATE_FORMAT(b.created_at, '%Y-%m-%d') as booking_date,
    b.reference_code,
    r.name as room_type,
    b.adults_count,
    b.children_count,
    b.child_ages,
    -- Count how many children are chargeable (ages 7-13)
    -- Manual verification recommended
    CASE 
        WHEN b.child_ages IS NULL THEN 0
        WHEN JSON_CONTAINS(b.child_ages, '7') 
          OR JSON_CONTAINS(b.child_ages, '8')
          OR JSON_CONTAINS(b.child_ages, '9')
          OR JSON_CONTAINS(b.child_ages, '10')
          OR JSON_CONTAINS(b.child_ages, '11')
          OR JSON_CONTAINS(b.child_ages, '12')
          OR JSON_CONTAINS(b.child_ages, '13') THEN 'Has Chargeable Child'
        ELSE 'All Free'
    END as surcharge_status,
    CONCAT('‚Ç±', FORMAT(b.total_amount, 2)) as total_amount,
    b.status
FROM bookings b
JOIN rooms r ON b.room_id = r.room_id
WHERE b.children_count > 0
ORDER BY b.created_at DESC;

-- -----------------------------------------------------------------------------
-- 8. DATA INTEGRITY CHECK
-- Ensure children_count matches the number of ages in child_ages array
-- -----------------------------------------------------------------------------
SELECT 
    reference_code,
    children_count,
    child_ages,
    JSON_LENGTH(child_ages) as ages_provided,
    CASE 
        WHEN children_count = 0 AND child_ages IS NULL THEN 'OK'
        WHEN children_count > 0 AND JSON_LENGTH(child_ages) = children_count THEN 'OK'
        WHEN children_count > 0 AND child_ages IS NULL THEN 'ERROR: Missing ages'
        WHEN children_count != JSON_LENGTH(child_ages) THEN 'ERROR: Count mismatch'
        ELSE 'UNKNOWN'
    END as data_integrity_status
FROM bookings
WHERE created_at >= DATE_SUB(NOW(), INTERVAL 30 DAY)  -- Last 30 days
ORDER BY created_at DESC;

-- -----------------------------------------------------------------------------
-- 9. REVENUE ANALYSIS: Child Surcharge Contribution
-- Calculate total revenue from child surcharges
-- -----------------------------------------------------------------------------
SELECT 
    DATE_FORMAT(created_at, '%Y-%m') as month,
    COUNT(*) as bookings_with_children,
    SUM(children_count) as total_children,
    -- Approximate surcharge (actual calculation needs JSON parsing)
    -- This assumes average ‚Ç±100 per child (mix of free and ‚Ç±150)
    CONCAT('‚Ç±', FORMAT(SUM(children_count) * 100, 2)) as estimated_child_revenue
FROM bookings
WHERE children_count > 0
  AND status IN ('Confirmed', 'Checked_In', 'Completed')
GROUP BY DATE_FORMAT(created_at, '%Y-%m')
ORDER BY month DESC;

-- -----------------------------------------------------------------------------
-- 10. LATEST BOOKING DETAILS
-- Get the most recent booking to verify current implementation
-- -----------------------------------------------------------------------------
SELECT 
    *
FROM bookings
ORDER BY created_at DESC
LIMIT 1;

-- -----------------------------------------------------------------------------
-- DONE! Run these queries to verify your child policy implementation
-- For issues, check:
-- 1. Server logs: Look for "üë∂ Child Policy Applied" messages
-- 2. Frontend: Inspect Network tab for payload sent to backend
-- 3. Database: Verify child_ages column has valid JSON arrays
-- -----------------------------------------------------------------------------
</file>

<file path="server.js">
const express = require('express');
const cors = require('cors');
require('dotenv').config(); // Load environment variables first
const validateRequiredEnvVars = require('./config/validateEnv'); // Validate env vars

// üîí SECURITY: Environment Validation (Section 2.2)
// Validate all required environment variables before starting server
validateRequiredEnvVars();

const sequelize = require('./config/database');
const authRoutes = require('./routes/authRoutes');
const roomRoutes = require('./routes/roomRoutes');
const paymentRoutes = require('./routes/paymentRoutes');
const paymentController = require('./controllers/paymentController');

// üß™ DEV ONLY: Development/Testing routes
const devRoutes = require('./routes/devRoutes');

// üîí SECURITY: Middleware imports (Sections 2.4, 2.5)
const sanitizeRequestBody = require('./middleware/sanitize');
const { apiLimiter } = require('./middleware/rateLimiters');

// üîí SECURITY: Error Handling (Section 2.8)
const AppError = require('./utils/AppError');
const errorController = require('./controllers/errorController');

// üîá PRODUCTION MODE: Suppress verbose logging
if (process.env.NODE_ENV === 'production') {
  console.log = function() {}; // Mute verbose logs
  console.debug = function() {}; // Mute debug logs
  console.info = function() {}; // Mute info logs
  // ‚ö†Ô∏è Keep console.error and console.warn active for critical issues
  console.error('üîí Production mode: Verbose logging suppressed (errors/warnings still active)');
} else {
  console.log('üîß Development mode: All console output enabled');
}

const app = express();
const PORT = process.env.PORT || 3000;

// üîí SECURITY: CORS Configuration (Section 2.10)
// Only allow requests from authorized origins
const allowedOrigins = process.env.NODE_ENV === 'production'
  ? [process.env.FRONTEND_URL, process.env.IMS_URL].filter(Boolean) // Only production URLs (filter out undefined)
  : ['http://localhost:5173', 'http://localhost:5174']; // Dev URLs

app.use(cors({
  origin: (origin, callback) => {
    // Allow requests with no origin (mobile apps, Postman, server-to-server)
    if (!origin) return callback(null, true);
    
    if (allowedOrigins.includes(origin)) {
      callback(null, true);
    } else {
      console.warn(`‚ö†Ô∏è CORS blocked request from unauthorized origin: ${origin}`);
      callback(new Error('Not allowed by CORS'));
    }
  },
  credentials: true // Allow cookies/auth headers
}));

// üîí SECURITY: Webhook Route (Section 2.13)
// Must come BEFORE express.json() to receive raw body for signature verification
app.post('/api/payment/webhook', express.raw({ type: 'application/json' }), paymentController.handleWebhook);

// üîí SECURITY: Request Body Size Limits (Section 2.9)
// Prevent DoS attacks via massive JSON/form payloads
app.use(express.json({ limit: '10kb' }));
app.use(express.urlencoded({ extended: true, limit: '10kb' }));

// üîí SECURITY: Input Sanitization (Section 2.4)
// Strip HTML tags and malicious content from all request bodies
app.use(sanitizeRequestBody);

// üîí SECURITY: Rate Limiting (Section 2.5)
// General API rate limiter - 100 requests per 15 minutes
app.use('/api/', apiLimiter);

// Routes
app.use('/api/auth', authRoutes);
app.use('/api/rooms', roomRoutes);
app.use('/api/payment', paymentRoutes);

// üß™ DEV ONLY: Development/Testing routes
// Only mount dev routes in non-production environments
if (process.env.NODE_ENV !== 'production') {
  app.use('/api/dev', devRoutes);
  console.log('üß™ Dev routes enabled at /api/dev (payment simulator available)');
} else {
  console.log('üîí Production mode: Dev routes disabled');
}

// üîí SECURITY: 404 Handler (Section 2.8)
// Handle all undefined routes with proper error response
app.use((req, res, next) => {
  next(new AppError(`Cannot find ${req.originalUrl} on this server!`, 404));
});

// üîí SECURITY: Global Error Handler (Section 2.8)
// Centralized error handling - must be last middleware
app.use(errorController);

// Test Database Connection
sequelize.authenticate()
  .then(() => {
    console.log('‚úÖ Database connected to XAMPP MySQL!');
    // Sync models with database
    return sequelize.sync({ alter: false });
  })
  .then(() => {
    console.log('‚úÖ Database models synced');
  })
  .catch(err => console.error('‚ùå Database connection error:', err));

app.listen(PORT, () => {
  console.log(`Server running on port ${PORT}`);
});

// Global error handler
app.use((err, req, res, next) => {
  console.error('‚ùå Global error handler:', err);
  const statusCode = err.statusCode || 500;
  const message = err.message || 'Internal Server Error';
  res.status(statusCode).json({ error: message });
});

// 404 handler
app.use((req, res) => {
  res.status(404).json({ error: 'Not Found' });
});
</file>

<file path="utils/AppError.js">
/**
 * Custom Error Class for Operational Errors
 * Distinguishes between operational errors (expected) and programming bugs
 */
class AppError extends Error {
  constructor(message, statusCode) {
    super(message);
    
    this.statusCode = statusCode;
    this.status = `${statusCode}`.startsWith('4') ? 'fail' : 'error';
    this.isOperational = true; // Mark as operational (not a programming bug)
    
    Error.captureStackTrace(this, this.constructor);
  }
}

module.exports = AppError;
</file>

</files>
